<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Curve Simulator & Throw Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas and inputs */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .input-group {
            @apply border border-gray-400 p-2 mb-4 rounded bg-white;
        }
        .input-row {
            @apply flex items-center gap-2 mb-2 text-sm;
        }
        .input-label {
            @apply w-32 font-medium text-gray-700;
        }
        .input-field {
            @apply border border-gray-300 rounded px-2 py-1 w-24 text-right focus:outline-none focus:border-blue-500;
        }
        .section-header {
            @apply font-bold text-gray-800 mb-2 border-b border-gray-200 pb-1;
        }
        /* Custom radio button styling */
        input[type="radio"] {
            accent-color: #2563eb; 
            transform: scale(1.2);
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 h-screen w-screen overflow-hidden flex flex-col">

    <!-- MAIN LAYOUT CONTAINER (Full Width/Height) -->
    <div class="flex-1 grid grid-cols-1 lg:grid-cols-12 h-full w-full">
        
        <!-- CONTROL PANEL (Scrollable Sidebar) -->
        <div class="lg:col-span-3 h-full overflow-y-auto p-4 border-r border-gray-200 bg-gray-50 z-10 shadow-sm">
            
            <h1 class="text-xl font-bold mb-4 text-gray-900">Input Parameters</h1>

            <div class="input-group">
                <div class="input-row">
                    <input type="radio" name="rad_sel" checked class="mr-2">
                    <span class="font-bold mr-auto">Radius (R) [m]</span>
                    <input type="number" id="input_R" value="100" class="input-field w-32">
                </div>
            </div>

            <div class="input-group">
                <div class="flex items-center gap-2 mb-1">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_L_veh" class="text-xs font-bold text-gray-500 w-12 text-right">L_veh</label>
                        <input type="number" id="input_L_veh" class="input-field w-full" value="21000">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_B_veh" class="text-xs font-bold text-gray-500 w-12 text-right">B_veh</label>
                        <input type="number" id="input_B_veh" class="input-field w-full" value="15850">
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_h" class="text-xs font-bold text-gray-500 w-12 text-right">h</label>
                        <input type="number" id="input_h" class="input-field w-full" value="400">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_w" class="text-xs font-bold text-gray-500 w-12 text-right">w</label>
                        <input type="number" id="input_w" class="input-field w-full" value="2540">
                    </div>
                </div>
            </div>

            <div class="input-group">
                <!-- Header with explicit column widths to match rows -->
                <div class="flex items-center gap-2 mb-2 px-1 text-xs font-bold text-gray-500">
                    <span class="w-6"></span> <!-- Space for Radio -->
                    <span class="flex-1">Outline</span>
                    <span class="w-12 text-center">ID</span>
                    <span class="w-16 text-center">L</span>
                    <span class="w-16 text-center">B</span>
                </div>

                <div class="space-y-1">
                    <!-- Row 1 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs1" class="w-4 h-4 cursor-pointer" onchange="setOutline(1, 16200, 11000)">
                        <label for="rs1" class="flex-1 cursor-pointer font-medium text-sm">RS1</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:1</span>
                        <span class="w-16"></span> <!-- Empty L spacer -->
                        <span class="w-16"></span> <!-- Empty B spacer -->
                    </div>
                    <!-- Row 2 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs2" class="w-4 h-4 cursor-pointer" onchange="setOutline(2, 19150, 14000)">
                        <label for="rs2" class="flex-1 cursor-pointer font-medium text-sm">RS2</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:2</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                    <!-- Row 3 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs3" class="w-4 h-4 cursor-pointer" onchange="setOutline(3, 19150, 14000)">
                        <label for="rs3" class="flex-1 cursor-pointer font-medium text-sm">RS3</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:3</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                    <!-- Row 4 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs4" class="w-4 h-4 cursor-pointer" checked onchange="setOutline(4, 21000, 15850)">
                        <label for="rs4" class="flex-1 cursor-pointer font-medium text-sm">RS4</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:4</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                </div>

                <!-- Active inputs with Labels explicitly beside them -->
                <div class="border-t border-gray-200 mt-2 pt-2 flex items-center gap-2">
                    <div class="text-xs font-bold text-gray-500 w-12">Active:</div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">L</span>
                         <input type="number" id="input_L_outline" class="input-field w-full" value="21000">
                    </div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">B</span>
                         <input type="number" id="input_B_outline" class="input-field w-full" value="15850">
                    </div>
                </div>
            </div>

            <!-- CURVE DIRECTION (New Control) -->
            <div class="input-group border-l-4 border-l-blue-500">
                <div class="section-header text-blue-800">Curve Direction</div>
                <div class="input-row">
                    <input type="radio" name="curve_dir" id="curve_cw" value="cw" checked class="mr-2" onchange="runCalculation()">
                    <label for="curve_cw" class="flex-1 cursor-pointer font-bold">Clockwise</label>
                    <span class="bg-blue-100 text-blue-800 px-2 rounded text-xs">Right Turn</span>
                </div>
                <div class="input-row">
                    <input type="radio" name="curve_dir" id="curve_ccw" value="ccw" class="mr-2" onchange="runCalculation()">
                    <label for="curve_ccw" class="flex-1 cursor-pointer font-bold">Counter-Clockwise</label>
                    <span class="bg-blue-100 text-blue-800 px-2 rounded text-xs">Left Turn</span>
                </div>
                <div class="mt-2 text-xs text-gray-500">
                    Controls Roll Direction &amp; Throw Assignment (ET/CT).
                </div>
            </div>

            <div class="input-group">
                <div class="flex justify-between mb-2 px-2 text-xs font-bold text-gray-500">
                    <span class="w-20 text-center">Roll (deg)</span>
                    <span class="w-20 text-center">Lat (mm)</span>
                    <span class="w-20 text-center">Bounce (mm)</span>
                </div>
                <div class="input-row">
                    <input type="radio" checked disabled class="mr-2 opacity-50">
                    <label class="flex-1 text-sm">Parameters</label>
                </div>
                <div class="grid grid-cols-3 gap-2 pt-1">
                    <input type="number" id="input_roll" class="input-field w-full" value="1.25" step="0.1">
                    <input type="number" id="input_lat" class="input-field w-full" value="43">
                    <input type="number" id="input_bounce" class="input-field w-full" value="50">
                </div>
            </div>
            
            <button onclick="runCalculation()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow mt-2">
                Calculate & Plot
            </button>

             <!-- Removed text-based output, moved to canvas -->
             <div class="mt-4 text-xs text-gray-400 text-center">
                 Calculated values are now displayed directly on the graph.
             </div>

        </div>

        <!-- VISUALIZATION PANEL (Fills Remaining Space) -->
        <div class="lg:col-span-9 h-full p-4 flex flex-col bg-gray-50 overflow-hidden">
            <div class="bg-white rounded-lg shadow-lg p-1 border border-gray-200 flex-1 flex flex-col relative overflow-hidden">
                <!-- Canvas Container takes full height/width -->
                <div class="relative w-full h-full">
                    <canvas id="plotCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // 1. DATA & CONSTANTS
        // =================================================================
        
        const PIVOT_POINT = { x: 0, y: 1100 };

        // Parsed Outline Data
        const OUTLINE_DATA_SETS = {
            1: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1220,y:535,type:1}, {x:1220,y:825,type:1}, {x:1315,y:915,type:1},
                {x:1425,y:915,type:1}, 
                {x:1425,y:3250,type:2, cx:-328, cy:1468, r:2500},
                {x:250,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            2: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1450,y:915,type:1}, {x:1450,y:2845,type:1}, {x:1412,y:3415,type:1},
                {x:1040,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            3: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1450,y:915,type:1}, {x:1450,y:2845,type:1}, {x:1400,y:3600,type:1},
                {x:1080,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            4: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1430,y:915,type:1}, {x:1430,y:1850,type:1}, {x:1350,y:3250,type:1},
                {x:1000,y:3584.9943,type:2, cx:-328, cy:1468, r:2500},
                {x:247,y:3900,type:1}, {x:0,y:3900,type:1}
            ]
        };

        let currentOutlineId = 4;

        // =================================================================
        // 2. MATH HELPERS
        // =================================================================

        function radians(deg) { return deg * Math.PI / 180; }

        function getRotatedCoords(x, y, angleDeg, cx, cy) {
            const rad = radians(angleDeg);
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            const dx = x - cx;
            const dy = y - cy;
            return {
                x: cx + dx * c - dy * s,
                y: cy + dx * s + dy * c
            };
        }

        function getArcPoints(pStart, pEnd, cx, cy, radius, numPoints = 20) {
            let startAngle = Math.atan2(pStart.y - cy, pStart.x - cx);
            let endAngle = Math.atan2(pEnd.y - cy, pEnd.x - cx);

            // Handle wrapping across PI/-PI boundary
            if (Math.abs(endAngle - startAngle) > Math.PI) {
                if (endAngle > startAngle) startAngle += 2 * Math.PI;
                else endAngle += 2 * Math.PI;
            }

            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = startAngle + (endAngle - startAngle) * (i / numPoints);
                points.push({
                    x: cx + radius * Math.cos(t),
                    y: cy + radius * Math.sin(t)
                });
            }
            return points;
        }

        // Linear interpolation to find X at a given Y
        function getXAtY(targetY, polyPoints, side = 'right') {
            const intersections = [];
            for (let i = 0; i < polyPoints.length - 1; i++) {
                const p1 = polyPoints[i];
                const p2 = polyPoints[i+1];

                const y1 = p1.y, y2 = p2.y;
                const x1 = p1.x, x2 = p2.x;

                // Check interval
                if ((y1 <= targetY && targetY <= y2) || (y2 <= targetY && targetY <= y1)) {
                    if (y1 === y2) {
                        intersections.push(x1, x2);
                    } else {
                        const slope = (x2 - x1) / (y2 - y1);
                        const x = x1 + (targetY - y1) * slope;
                        intersections.push(x);
                    }
                }
            }

            if (intersections.length === 0) return null;
            return side === 'right' ? Math.max(...intersections) : Math.min(...intersections);
        }

        // Point inside polygon (Ray casting)
        function pointInPolygon(point, vs) {
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i].x, yi = vs[i].y;
                let xj = vs[j].x, yj = vs[j].y;
                
                let intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // =================================================================
        // 3. UI HANDLERS
        // =================================================================

        function setVehicle(L, B, h, w) {
            document.getElementById('input_L_veh').value = L;
            document.getElementById('input_B_veh').value = B;
            document.getElementById('input_h').value = h;
            document.getElementById('input_w').value = w;
            runCalculation();
        }

        function setOutline(id, L, B) {
            currentOutlineId = id;
            document.getElementById('input_L_outline').value = L;
            document.getElementById('input_B_outline').value = B;
            runCalculation();
        }

        function runCalculation() {
            // 1. Gather Inputs
            const R_meters = parseFloat(document.getElementById('input_R').value);
            const R_mm = R_meters * 1000;

            const L_veh = parseFloat(document.getElementById('input_L_veh').value);
            const B_veh = parseFloat(document.getElementById('input_B_veh').value);
            const h = parseFloat(document.getElementById('input_h').value);
            const w = parseFloat(document.getElementById('input_w').value);
            
            const L_outline = parseFloat(document.getElementById('input_L_outline').value);
            const B_outline = parseFloat(document.getElementById('input_B_outline').value);
            
            const isCW = document.getElementById('curve_cw').checked;
            const rollMag = parseFloat(document.getElementById('input_roll').value);
            const latMag = parseFloat(document.getElementById('input_lat').value);
            const bounce = parseFloat(document.getElementById('input_bounce').value);

            // --- CURVE DYNAMICS LOGIC ---
            // CW (Clockwise/Right Turn):
            //   - Outside Rail is Left.
            //   - Vehicle Rolls to Outside (Left).
            //   - Lateral Force to Outside (Left).
            //   - Left Side = End Throw (Headswing).
            //   - Right Side = Center Throw (Centerswing).
            
            // CCW (Counter-Clockwise/Left Turn):
            //   - Outside Rail is Right.
            //   - Vehicle Rolls to Outside (Right).
            //   - Lateral Force to Outside (Right).
            //   - Right Side = End Throw.
            //   - Left Side = Center Throw.

            // 1. Roll Angle (Standard Math: Pos = CCW)
            // CW Curve -> Roll Left (CCW) -> Positive Angle
            // CCW Curve -> Roll Right (CW) -> Negative Angle
            const rollAngle = isCW ? Math.abs(rollMag) : -Math.abs(rollMag);

            // 2. Lateral Shift (Standard: Pos X = Right, Neg X = Left)
            // CW Curve -> Force Left -> Negative X
            // CCW Curve -> Force Right -> Positive X
            const latGlobal = isCW ? -latMag : latMag;


            // 2. Calculate Throws
            let calc_ET = 0, calc_CT = 0; // For Outline
            let veh_ET = 0, veh_CT = 0;   // For Points

            if (R_mm !== 0) {
                // Formula: (L^2 - B^2) / 8R
                calc_ET = (Math.pow(L_outline, 2) - Math.pow(B_outline, 2)) / (8 * R_mm);
                calc_CT = Math.pow(B_outline, 2) / (8 * R_mm);

                veh_ET = (Math.pow(L_veh, 2) - Math.pow(B_veh, 2)) / (8 * R_mm);
                veh_CT = Math.pow(B_veh, 2) / (8 * R_mm);
            }

            // 3. Prepare Outline Data
            const rawPoints = OUTLINE_DATA_SETS[currentOutlineId];
            if(!rawPoints) return;

            const ys = rawPoints.map(p => p.y);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const vHeight = (maxY - minY) || 1;
            
            // 4. Generate Polygons
            // Added throw_type to track what was applied for labeling
            const polyCoords = { 
                left: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[], throw_type: ''}, 
                right: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[], throw_type: ''} 
            };

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;

                // Determine Throw based on Curve Direction & Side
                let throwVal = 0;
                let throwTypeLabel = '';

                if (isCW) {
                    // Clockwise: Left=ET, Right=CT
                    if (side === 'left') { throwVal = calc_ET; throwTypeLabel = 'ET'; }
                    else { throwVal = calc_CT; throwTypeLabel = 'CT'; }
                } else {
                    // Counter-Clockwise: Left=CT, Right=ET
                    if (side === 'left') { throwVal = calc_CT; throwTypeLabel = 'CT'; }
                    else { throwVal = calc_ET; throwTypeLabel = 'ET'; }
                }
                
                polyCoords[side].throw_type = throwTypeLabel;

                // Iterate segments
                for(let i=0; i<rawPoints.length-1; i++) {
                    const curr = rawPoints[i];
                    const next = rawPoints[i+1];
                    
                    const sx1 = curr.x * xMult, sy1 = curr.y;
                    const sx2 = next.x * xMult, sy2 = next.y;
                    
                    let segPoints = [];
                    if(curr.type === 1) {
                        segPoints.push({x: sx1, y: sy1});
                        segPoints.push({x: sx2, y: sy2});
                    } else if(curr.type === 2) {
                        const cx = curr.cx * xMult;
                        const arcPts = getArcPoints({x:sx1, y:sy1}, {x:sx2, y:sy2}, cx, curr.cy, curr.r);
                        segPoints = arcPts;
                    }
                    
                    segPoints.forEach(p => {
                        // 1. Original Static (Upright)
                        polyCoords[side].static_x.push(p.x);
                        polyCoords[side].static_y.push(p.y);

                        // 2. Rotated Static (Just the body rotated, no throw/lat)
                        const rotS = getRotatedCoords(p.x, p.y, rollAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        polyCoords[side].rot_static_x.push(rotS.x);
                        polyCoords[side].rot_static_y.push(p.y);

                        // 3. Apply Body Deformations (Throw) & Suspension (Bounce)
                        // This establishes the vehicle shape in its local frame.
                        const x_local = p.x + (throwVal * xMult);
                        
                        // FIX: Uniform bounce (rigid body) instead of scaling from const ty = p.y + (p.y - minY) / vHeight * bounce; 
                        const y_local = p.y + bounce; 

                        // B. Rotate (Roll)
                        // Rotate the expanded body around the Pivot Point (Roll Center)
                        const rot = getRotatedCoords(x_local, y_local, rollAngle, PIVOT_POINT.x, PIVOT_POINT.y);

                        // C. Translate (Lateral Shift)
                        // Shift the now-rotated body laterally. 
                        // Note: latGlobal is added AFTER rotation.
                        const final_x = rot.x + latGlobal;
                        const final_y = rot.y; // IMPORTANT: Use rot.y to capture the tilt!
                        
                        polyCoords[side].x.push(final_x);
                        polyCoords[side].y.push(final_y); 
                    });
                }
            });

            // 5. Calculate Study Points
            const h_bounced = h + ((h - minY) / vHeight) * bounce;
            const studyPoints = [];
            const results = [];

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;
                
                // Determine Throw for Study Points (using veh_ET/veh_CT)
                let ptThrowVal = 0;
                let ptThrowType = '';
                if (isCW) {
                    if (side === 'left') { ptThrowVal = veh_ET; ptThrowType = 'ET'; }
                    else { ptThrowVal = veh_CT; ptThrowType = 'CT'; }
                } else {
                    if (side === 'left') { ptThrowVal = veh_CT; ptThrowType = 'CT'; }
                    else { ptThrowVal = veh_ET; ptThrowType = 'ET'; }
                }

                // Calc position
                // Start at w/2 on the correct side
                // Add Global Lat shift
                // Add Throw Expansion (Throw is expansion, so moves further out)
                const x_raw = (w/2 * xMult) + latGlobal + (ptThrowVal * xMult);
                const y_pos = h_bounced;

                // Rotate
                const p_rot = getRotatedCoords(x_raw, y_pos, rollAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                
                studyPoints.push({
                    x: p_rot.x, 
                    y: y_pos, 
                    side: side,
                    type: ptThrowType, // Store type for label
                    color: (ptThrowType === 'ET' ? '#059669' : '#d946ef') // Green(ET) or Magenta(CT)
                });

                const y_check = y_pos; 

                // --- Calculate Deltas ---
                // 1. Rotated Static Delta
                const rotStaticPts = polyCoords[side].rot_static_x.map((x, i) => ({x: x, y: polyCoords[side].rot_static_y[i]}));
                const rotStaticX = getXAtY(y_check, rotStaticPts, side);
                
                // 2. Original Static Delta
                const origStaticPts = polyCoords[side].static_x.map((x, i) => ({x: x, y: polyCoords[side].static_y[i]}));
                const origStaticX = getXAtY(y_check, origStaticPts, side);

                // 3. Envelope Delta
                const envPts = polyCoords[side].x.map((x, i) => ({x: x, y: polyCoords[side].y[i]}));
                const envX = getXAtY(y_check, envPts, side);

                results.push({ 
                    side: side, 
                    throwType: ptThrowType,
                    p: {x: p_rot.x, y: y_pos}, 
                    rotStaticX: rotStaticX, 
                    origStaticX: origStaticX, 
                    envX: envX 
                });
            });

            // 6. Draw
            draw(polyCoords, studyPoints, results, {roll: rollMag, lat: latMag, bounce, isCW});
        }

        // =================================================================
        // 4. DRAWING
        // =================================================================

        function draw(polyCoords, studyPoints, results, params) {
            const canvas = document.getElementById('plotCanvas');
            const ctx = canvas.getContext('2d');
            
            const parent = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = parent.clientWidth * dpr;
            canvas.height = parent.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const width = parent.clientWidth;
            const height = parent.clientHeight;
            ctx.clearRect(0, 0, width, height);

            // --- Scaling ---
            let allX = [], allY = [];
            allX.push(PIVOT_POINT.x); allY.push(PIVOT_POINT.y);
            ['right', 'left'].forEach(s => {
                allX.push(...polyCoords[s].x, ...polyCoords[s].static_x, ...polyCoords[s].rot_static_x);
                allY.push(...polyCoords[s].y, ...polyCoords[s].static_y);
            });
            studyPoints.forEach(sp => { allX.push(sp.x); allY.push(sp.y); });

            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);

            const marginX = 800; 
            const marginY = 800;
            const dataW = (maxX - minX) + marginX * 2;
            const dataH = (maxY - minY) + marginY * 2;
            
            const plotXStart = 60; 
            const plotYStart = 60; 
            const plotW = width - plotXStart - 20; 
            const plotH = height - plotYStart - 40; 

            const scaleX = plotW / dataW;
            const scaleY = plotH / dataH;
            const scale = Math.min(scaleX, scaleY);

            const dataCx = (minX + maxX) / 2;
            const dataCy = (minY + maxY) / 2;

            const cx = plotXStart + plotW / 2;
            const cy = plotYStart + plotH / 2;

            function toScreen(x, y) {
                return {
                    x: cx + (x - dataCx) * scale,
                    y: cy - (y - dataCy) * scale 
                };
            }

            // --- Grid ---
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,width,height);

            ctx.save();
            ctx.strokeStyle = '#e5e7eb'; 
            ctx.lineWidth = 0.8;
            ctx.setLineDash([4, 4]); 
            
            const gridSize = 500; 
            const startGridX = Math.floor((minX - marginX)/gridSize)*gridSize;
            const endGridX = Math.ceil((maxX + marginX)/gridSize)*gridSize;
            const startGridY = Math.floor((minY - marginY)/gridSize)*gridSize;
            const endGridY = Math.ceil((maxY + marginY)/gridSize)*gridSize;

            ctx.font = '10px Arial';
            ctx.fillStyle = '#9ca3af';

            ctx.textAlign = 'center';
            for(let gx = startGridX; gx <= endGridX; gx += gridSize) {
                const p = toScreen(gx, 0);
                if(p.x >= plotXStart && p.x <= width) {
                    ctx.beginPath(); ctx.moveTo(p.x, plotYStart); ctx.lineTo(p.x, height - 20); ctx.stroke();
                    if(gx % 1000 === 0) ctx.fillText(gx, p.x, height - 5);
                }
            }
            ctx.textAlign = 'right';
            for(let gy = startGridY; gy <= endGridY; gy += gridSize) {
                const p = toScreen(0, gy);
                if(p.y >= plotYStart && p.y <= height - 20) {
                    ctx.beginPath(); ctx.moveTo(plotXStart, p.y); ctx.lineTo(width, p.y); ctx.stroke();
                    if(gy % 1000 === 0) ctx.fillText(gy, plotXStart - 5, p.y + 3);
                }
            }
            ctx.restore();

            // Axis Titles
            ctx.save();
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("x (mm)", plotXStart + plotW/2, height - 5);
            ctx.translate(15, plotYStart + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("y (mm)", 0, 0);
            ctx.restore();

            // --- 1. Draw Original Static Vehicle (Solid Blue) ---
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1.0; 
            ctx.setLineDash([]);
            ctx.beginPath();
            
            ['left', 'right'].forEach(s => {
                const pts = polyCoords[s].static_x.map((x, i) => ({x, y: polyCoords[s].static_y[i]}));
                if(pts.length) {
                    const st = toScreen(pts[0].x, pts[0].y);
                    ctx.moveTo(st.x, st.y);
                    for(let i=1; i<pts.length; i++) {
                        const p = toScreen(pts[i].x, pts[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                }
            });
            ctx.stroke();

            // --- 2. Draw Rotated Static Vehicle (Dotted Blue + Shaded) ---
            // Construct polygon
            const rotPoly = [];
            polyCoords.left.rot_static_x.forEach((x, i) => rotPoly.push({x: x, y: polyCoords.left.rot_static_y[i]}));
            for(let i = polyCoords.right.rot_static_x.length - 1; i >= 0; i--) {
                rotPoly.push({x: polyCoords.right.rot_static_x[i], y: polyCoords.right.rot_static_y[i]});
            }

            ctx.save();
            ctx.beginPath();
            if(rotPoly.length) {
                const s = toScreen(rotPoly[0].x, rotPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<rotPoly.length; i++) {
                    const p = toScreen(rotPoly[i].x, rotPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }
            ctx.fillStyle = 'rgba(59, 130, 246, 0.15)'; 
            ctx.fill();
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([2, 3]);
            ctx.stroke();
            ctx.restore();

            // --- 3. Construct Dynamic Envelope Polygon ---
            const fullPoly = [];
            polyCoords.left.x.forEach((x, i) => fullPoly.push({x: x, y: polyCoords.left.y[i]}));
            for(let i = polyCoords.right.x.length - 1; i >= 0; i--) {
                fullPoly.push({x: polyCoords.right.x[i], y: polyCoords.right.y[i]});
            }

            let globalStatus = 'PASS'; 
            const TOLERANCE_MM = 1e-9;
            
            if (fullPoly.length > 0 && studyPoints.length > 0) {
                let hasFail = false;
                let hasBoundary = false;
                studyPoints.forEach((sp, idx) => {
                    const isStrictlyInside = pointInPolygon(sp, fullPoly);
                    const res = results[idx];
                    let isLocalBoundary = false;
                    if (res && res.envX !== null) {
                         const dist = Math.abs(sp.x - res.envX);
                         if (dist <= TOLERANCE_MM) {
                             hasBoundary = true;
                             isLocalBoundary = true;
                         }
                    }
                    if (!isLocalBoundary && !isStrictlyInside) hasFail = true;
                });
                if (hasFail) globalStatus = 'FAIL';
                else if (hasBoundary) globalStatus = 'BOUNDARY';
            }

            // --- 4. Draw Dynamic Envelope ---
            ctx.beginPath();
            if(fullPoly.length) {
                const s = toScreen(fullPoly[0].x, fullPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<fullPoly.length; i++) {
                    const p = toScreen(fullPoly[i].x, fullPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }
            if (globalStatus === 'FAIL') ctx.fillStyle = 'rgba(254, 202, 202, 0.4)'; // Red
            else if (globalStatus === 'BOUNDARY') ctx.fillStyle = 'rgba(251, 191, 36, 0.4)'; // Amber
            else ctx.fillStyle = 'rgba(230, 249, 230, 0.4)'; // Green
            ctx.fill();
            ctx.strokeStyle = '#FF6347'; // Tomato
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Pivot
            const piv = toScreen(PIVOT_POINT.x, PIVOT_POINT.y);
            ctx.fillStyle = 'black'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
            const plusSize = 6;
            ctx.beginPath();
            ctx.moveTo(piv.x - plusSize, piv.y); ctx.lineTo(piv.x + plusSize, piv.y);
            ctx.moveTo(piv.x, piv.y - plusSize); ctx.lineTo(piv.x, piv.y + plusSize);
            ctx.stroke();

            // --- Draw Study Points & Annotations (BOTH SIDES) ---
            studyPoints.forEach((sp, idx) => {
                const scr = toScreen(sp.x, sp.y);
                
                // Marker
                ctx.strokeStyle = sp.color || '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(scr.x - 4, scr.y); ctx.lineTo(scr.x + 4, scr.y);
                ctx.moveTo(scr.x, scr.y - 4); ctx.lineTo(scr.x, scr.y + 4);
                ctx.stroke();

                // Annotations
                const res = results[idx];
                const isLeft = (sp.side === 'left');
                const textAlign = isLeft ? 'right' : 'left';
                const textXOffset = isLeft ? -10 : 10;
                
                // Y label
                ctx.font = '11px Arial';
                ctx.fillStyle = '#008000';
                ctx.textAlign = textAlign;
                ctx.fillText(`y:${sp.y.toFixed(0)}`, scr.x + textXOffset, scr.y - 30);

                // X drop line
                const axisY = height - 20; 
                ctx.save();
                ctx.setLineDash([2, 2]);
                ctx.strokeStyle = '#008000'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(scr.x, scr.y); ctx.lineTo(scr.x, axisY); ctx.stroke();
                ctx.restore();
                ctx.textAlign = 'center';
                ctx.fillText(`${sp.x.toFixed(0)}`, scr.x, height - 5);

                // --- Delta Lines ---
                
                // 1. Static Delta (Red Dotted) - Distance to Rotated Static
                if(res.rotStaticX !== null) {
                    const statScr = toScreen(res.rotStaticX, sp.y);
                    ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.lineWidth = 1.5; ctx.setLineDash([2, 2]);
                    ctx.moveTo(statScr.x, statScr.y); ctx.lineTo(scr.x, scr.y); ctx.stroke();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(statScr.x, statScr.y, 2, 0, 2*Math.PI); ctx.fill();

                    // Text: Dynamic Label (ET vs CT)
                    const dist = Math.abs(sp.x - res.rotStaticX);
                    ctx.font = 'bold 11px Arial';
                    ctx.fillStyle = 'red';
                    ctx.textAlign = textAlign;
                    ctx.fillText(`Δ ${res.throwType} Static: ${dist.toFixed(1)}`, scr.x + textXOffset, scr.y - 18);
                }

                // 2. Env Delta Line (Purple Dashed)
                if(res.envX !== null) {
                    const envScr = toScreen(res.envX, sp.y);
                    ctx.beginPath(); ctx.strokeStyle = '#800080'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
                    ctx.moveTo(envScr.x, envScr.y); ctx.lineTo(scr.x, scr.y); ctx.stroke();
                    
                    const dist = Math.abs(sp.x - res.envX);
                    ctx.font = 'bold 11px Arial';
                    ctx.fillStyle = '#4B0082';
                    ctx.textAlign = textAlign;
                    ctx.fillText(`Δ Env: ${dist.toFixed(1)}`, scr.x + textXOffset, scr.y - 6);
                }
            });

            // --- TITLE BLOCK ---
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const dirText = params.isCW ? "Clockwise (Right Turn)" : "Counter-Clockwise (Left Turn)";
            ctx.fillText(`Vehicle Outline Simulation - ${dirText}`, cx, 20);
            
            ctx.font = '14px Arial';
            let statusText = "PASS (Inside)";
            if (globalStatus === 'FAIL') statusText = "FAIL (Outside)";
            else if (globalStatus === 'BOUNDARY') statusText = "BOUNDARY (On Line)";
            
            ctx.fillText(`Status: ${statusText} | Roll: ${params.roll.toFixed(1)}° | Lat: ${params.lat.toFixed(1)}mm | Bounce: ${params.bounce.toFixed(1)}mm`, cx, 40);
            ctx.restore();

            // --- LEGEND ---
            drawLegend(ctx, width - 130, 10);
        }

        function drawLegend(ctx, x, y) {
            const w = 120;
            const h = 135;
            ctx.save();
            ctx.fillStyle = 'white'; ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
            ctx.fillRect(x, y, w, h); ctx.strokeRect(x, y, w, h);

            const items = [
                { color: 'black', text: 'Pivot (0, 1100)', type: 'symbol', symbol: '+' },
                { color: 'rgba(230, 249, 230, 1)', text: 'Throw Loop', type: 'rect' },
                { color: 'rgba(59, 130, 246, 0.4)', text: 'Rotated Static', type: 'dottedRect' },
                { color: '#2563eb', text: 'Original Static', type: 'line' },
                { color: '#008000', text: 'Point (ET/CT)', type: 'symbol', symbol: '+' },
                { color: 'red', text: 'Δ Static (Red)', type: 'dashed' },
                { color: '#800080', text: 'Δ Env (Purple)', type: 'dashed' },
            ];

            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let cy = y + 10;
            const lx = x + 10;
            const tx = x + 25;

            items.forEach(item => {
                ctx.fillStyle = 'black'; ctx.fillText(item.text, tx, cy);
                if(item.type === 'line') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 1.5; ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'dashed') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 1.5; ctx.setLineDash([3, 2]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'rect') {
                    ctx.fillStyle = item.color; ctx.strokeStyle = '#FF6347'; ctx.setLineDash([2,1]); ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6); ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'dottedRect') {
                    ctx.fillStyle = item.color; ctx.strokeStyle = '#2563eb'; ctx.setLineDash([1,2]); ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6); ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'symbol') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 2; ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(lx-3, cy); ctx.lineTo(lx+3, cy);
                    ctx.moveTo(lx, cy-3); ctx.lineTo(lx, cy+3);
                    ctx.stroke();
                }
                cy += 15;
            });
            ctx.restore();
        }

        document.querySelectorAll('input').forEach(inp => {
            if(inp.type === 'number') {
                inp.addEventListener('input', runCalculation);
            }
        });
        window.addEventListener('resize', runCalculation);
        window.onload = runCalculation;

    </script>
</body>
</html>
