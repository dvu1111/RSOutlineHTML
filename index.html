<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Curve Simulator & Throw Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas and inputs */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .input-group {
            @apply border border-gray-400 p-2 mb-4 rounded bg-white;
        }
        .input-row {
            @apply flex items-center gap-2 mb-2 text-sm;
        }
        .input-label {
            @apply w-32 font-medium text-gray-700;
        }
        .input-field {
            @apply border border-gray-300 rounded px-2 py-1 w-24 text-right focus:outline-none focus:border-blue-500;
        }
        .section-header {
            @apply font-bold text-gray-800 mb-2 border-b border-gray-200 pb-1;
        }
        /* Custom radio button styling */
        input[type="radio"] {
            accent-color: #2563eb; 
            transform: scale(1.2);
        }
        /* Select styling */
        select {
            @apply border border-gray-300 rounded px-2 py-1 text-sm bg-white focus:outline-none focus:border-blue-500;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 h-screen w-screen overflow-hidden flex flex-col">

    <!-- MAIN LAYOUT CONTAINER (Full Width/Height) -->
    <div class="flex-1 grid grid-cols-1 lg:grid-cols-12 h-full w-full">
        
        <!-- CONTROL PANEL (Scrollable Sidebar) -->
        <div class="lg:col-span-3 h-full overflow-y-auto p-4 border-r border-gray-200 bg-gray-50 z-10 shadow-sm">
            
            <h1 class="text-xl font-bold mb-4 text-gray-900">Input Parameters</h1>

            <div class="input-group">
                <div class="input-row">
                    <span class="font-bold mr-auto">Radius (R) [m]</span>
                    <input type="number" id="input_R" value="100" class="input-field w-32">
                </div>
            </div>

            <div class="input-group">
                <div class="flex items-center gap-2 mb-1">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_L_veh" class="text-xs font-bold text-gray-500 w-12 text-right">L_veh</label>
                        <input type="number" id="input_L_veh" class="input-field w-full" value="21000">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_B_veh" class="text-xs font-bold text-gray-500 w-12 text-right">B_veh</label>
                        <input type="number" id="input_B_veh" class="input-field w-full" value="15850">
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_h" class="text-xs font-bold text-gray-500 w-12 text-right">h</label>
                        <input type="number" id="input_h" class="input-field w-full" value="400">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_w" class="text-xs font-bold text-gray-500 w-12 text-right">w</label>
                        <input type="number" id="input_w" class="input-field w-full" value="2540">
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div class="section-header text-gray-800 flex justify-between items-center">
                    <span>Outline Selection</span>
                </div>

                <!-- Dropdown for Outline -->
                <div class="flex flex-col gap-2 mb-2">
                    <label for="outline_select" class="text-xs font-bold text-gray-500">Select Model:</label>
                    <select id="outline_select" onchange="setOutline(this.value)" class="w-full p-2 border border-gray-300 rounded">
                        <option value="RS1.1">RS1.1 (L=16200, B=11000)</option>
                        <option value="RS2.1">RS2.1 (L=19150, B=14000)</option>
                        <option value="RS3.1">RS3.1 (L=19150, B=14000)</option>
                        <option value="RS4.1" selected>RS4.1 (L=21000, B=15850)</option>
                    </select>
                </div>

                <!-- Active inputs with Labels explicitly beside them -->
                <div class="border-t border-gray-200 mt-2 pt-2 flex items-center gap-2">
                    <div class="text-xs font-bold text-gray-500 w-12">Ref Dims:</div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">L</span>
                         <input type="number" id="input_L_outline" class="input-field w-full" value="21000">
                    </div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">B</span>
                         <input type="number" id="input_B_outline" class="input-field w-full" value="15850">
                    </div>
                </div>
            </div>

            <!-- CURVE DIRECTION -->
            <div class="input-group border-l-4 border-l-blue-500">
                <div class="section-header text-blue-800">Curve Direction</div>
                <div class="input-row">
                    <input type="radio" name="curve_dir" id="curve_cw" value="cw" checked class="mr-2" onchange="runCalculation()">
                    <label for="curve_cw" class="flex-1 cursor-pointer font-bold">Clockwise</label>
                    <span class="bg-blue-100 text-blue-800 px-2 rounded text-xs">Right Turn</span>
                </div>
                <div class="input-row">
                    <input type="radio" name="curve_dir" id="curve_ccw" value="ccw" class="mr-2" onchange="runCalculation()">
                    <label for="curve_ccw" class="flex-1 cursor-pointer font-bold">Counter-Clockwise</label>
                    <span class="bg-blue-100 text-blue-800 px-2 rounded text-xs">Left Turn</span>
                </div>
            </div>

            <!-- TRACK TOLERANCES (New Section) -->
            <div class="input-group border-l-4 border-l-green-600">
                <div class="section-header text-green-800 flex items-center gap-2">
                    <input type="checkbox" id="enable_tolerances" class="w-4 h-4" onchange="updateToleranceInputs()">
                    <label for="enable_tolerances" class="cursor-pointer select-none">Track Tolerances</label>
                </div>
                
                <div id="tolerances_panel" class="opacity-50 pointer-events-none transition-opacity duration-200">
                    <div class="mb-2">
                        <label class="block text-xs font-bold text-gray-600 mb-1">Track Scenario</label>
                        <select id="track_scenario" class="w-full text-xs" onchange="updateToleranceInputs()">
                            <option value="ballasted_open">Ballasted open track</option>
                            <option value="ballasted_prescribed">Ballasted track in prescribed locations</option>
                            <option value="fixed_track">Fixed track</option>
                            <option value="fouling_point">Fouling Point - both tracks</option>
                        </select>
                    </div>
                    <div class="mb-2">
                        <label class="block text-xs font-bold text-gray-600 mb-1">Radius Scenario</label>
                        <select id="radius_scenario" class="w-full text-xs" onchange="updateToleranceInputs()">
                            <option value="gt_1000">Lateral Tolerance [mm] – Radius >1000m</option>
                            <option value="lte_1000">Lateral Tolerance [mm] – Radius ≤ 1000m</option>
                        </select>
                    </div>

                    <!-- Editable Tolerance Fields -->
                    <div class="mt-2 pt-2 border-t border-gray-200 grid grid-cols-2 gap-2">
                        <div>
                            <label class="block text-[10px] font-bold text-gray-500">Lat Tol (mm)</label>
                            <input type="number" id="input_tol_lat" class="input-field w-full h-6 text-xs" onchange="runCalculation()">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-gray-500">Vert Tol (mm)</label>
                            <input type="number" id="input_tol_vert" class="input-field w-full h-6 text-xs" onchange="runCalculation()">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-gray-500">Cant Tol (mm)</label>
                            <input type="number" id="input_tol_cant" class="input-field w-full h-6 text-xs" onchange="runCalculation()">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-gray-500">GW Tol (mm)</label>
                            <input type="number" id="input_tol_gw" class="input-field w-full h-6 text-xs" onchange="runCalculation()">
                        </div>
                    </div>

                    <div class="text-[10px] text-gray-500 italic mt-1 leading-tight">
                        *Values populated from Table 13.<br>
                        *You can manually edit values above.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div class="flex justify-between mb-2 px-2 text-xs font-bold text-gray-500">
                    <span class="w-20 text-center">Max Roll (deg)</span>
                    <span class="w-20 text-center">Lat (mm)</span>
                    <span class="w-20 text-center">Bounce (mm)</span>
                </div>

                <div class="flex items-center gap-2 mb-2 px-1 text-xs font-bold text-gray-500">
                    <span class="w-6"></span>
                    <span class="w-12 text-center">ID</span>
                    <span class="w-16 text-center">L</span>
                    <span class="w-16 text-center">B</span>
                </div>
                <div class="grid grid-cols-3 gap-2 pt-1 mb-3">
                    <input type="number" id="input_roll" class="input-field w-full" value="1.25" step="0.1">
                    <input type="number" id="input_lat" class="input-field w-full" value="43">
                    <input type="number" id="input_bounce" class="input-field w-full" value="50">
                </div>
                
                <div class="flex items-center gap-2 px-1 pt-2 border-t border-gray-200">
                    <label for="input_bounce_y" class="text-xs font-bold text-gray-700 w-auto">Bounce Start Y:</label>
                    <input type="number" id="input_bounce_y" class="input-field flex-1" value="535" title="Apply bounce only to points above this Y height">
                </div>
            </div>

            
            
            <button onclick="runCalculation()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow mt-2">
                Calculate & Plot
            </button>

             <div class="mt-4 text-xs text-gray-400 text-center">
                 Calculated values are now displayed directly on the graph.
             </div>

        </div>

        <!-- VISUALIZATION PANEL -->
        <div class="lg:col-span-9 h-full p-4 flex flex-col bg-gray-50 overflow-hidden">
            <div class="bg-white rounded-lg shadow-lg p-1 border border-gray-200 flex-1 flex flex-col relative overflow-hidden">
                <div class="relative w-full h-full">
                    <canvas id="plotCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // 1. DATA & CONSTANTS
        // =================================================================
        
        let PIVOT_POINT = { x: 0, y: 1100 };

        const TRACK_TOLERANCES = {
            'ballasted_open': { 
                lat_gt_1000: 25, lat_lte_1000: 25, 
                vert: 25, cant: 10, gw: 25 
            },
            'ballasted_prescribed': { 
                lat_gt_1000: 15, lat_lte_1000: 25, 
                vert: 15, cant: 10, gw: 25 
            },
            'fixed_track': { 
                lat_gt_1000: 5, lat_lte_1000: 5, 
                vert: 5, cant: 5, gw: 15 
            },
            'fouling_point': { 
                lat_gt_1000: 5, lat_lte_1000: 5, 
                vert: 5, cant: 5, gw: 15 
            }
        };

        const OUTLINE_DATA_SETS = {
            'RS1.1': {
                L: 16200, B: 11000, h_roll: 1100,
                points: [
                    {x:0, y:65}, {x:1195, y:65}, {x:1245, y:180}, {x:1245, y:305}, {x:1270, y:305},
                    {x:1270, y:535}, {x:1220, y:535}, {x:1220, y:825}, {x:1315, y:915}, {x:1425, y:915},
                    {x:1425, y:3250}, {x:1350, y:3321}, {x:1250, y:3407}, {x:1100, y:3520}, {x:950, y:3617},
                    {x:800, y:3699}, {x:650, y:3769}, {x:550, y:3809}, {x:450, y:3844}, {x:350, y:3874},
                    {x:250, y:3900}, {x:0, y:3900}
                ]
            },
            'RS2.1': {
                L: 19150, B: 14000, h_roll: 1100,
                points: [
                    {x:0, y:65}, {x:1195, y:65}, {x:1245, y:180}, {x:1245, y:305}, {x:1270, y:305},
                    {x:1270, y:535}, {x:1245, y:535}, {x:1245, y:845}, {x:1315, y:915}, {x:1450, y:915},
                    {x:1450, y:2845}, {x:1412, y:3415}, {x:1040, y:3900}, {x:930, y:3920}, {x:346, y:3950}, {x:0, y:3950}
                ]
            },
            'RS3.1': {
                L: 19150, B: 14000, h_roll: 1100,
                points: [
                    {x:0, y:65}, {x:1195, y:65}, {x:1245, y:180}, {x:1245, y:305}, {x:1270, y:305},
                    {x:1270, y:535}, {x:1245, y:535}, {x:1245, y:845}, {x:1315, y:915}, {x:1450, y:915},
                    {x:1450, y:2845}, {x:1400, y:3600}, {x:1080, y:3900}, {x:0, y:3900}
                ]
            },
            'RS4.1': {
                L: 21000, B: 15850, h_roll: 1100,
                points: [
                    {x:0, y:65}, {x:1195, y:65}, {x:1245, y:180}, {x:1245, y:305}, {x:1270, y:305},
                    {x:1270, y:535}, {x:1245, y:535}, {x:1245, y:845}, {x:1315, y:915}, {x:1430, y:915},
                    {x:1430, y:1850}, {x:1350, y:3250}, {x:700, y:3900}, {x:0, y:3900}
                ]
            }
        };

        let currentOutlineId = 'RS4.1';

        // =================================================================
        // 2. MATH HELPERS
        // =================================================================

        function radians(deg) { return deg * Math.PI / 180; }
        function degrees(rad) { return rad * 180 / Math.PI; }

        function getRotatedCoords(x, y, angleDeg, cx, cy) {
            const rad = radians(angleDeg);
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            const dx = x - cx;
            const dy = y - cy;
            return {
                x: cx + dx * c - dy * s,
                y: cy + dx * s + dy * c
            };
        }

        // Linear interpolation to find X at a given Y
        function getXAtY(targetY, polyPoints, side = 'right') {
            const intersections = [];
            for (let i = 0; i < polyPoints.length - 1; i++) {
                const p1 = polyPoints[i];
                const p2 = polyPoints[i+1];

                const y1 = p1.y, y2 = p2.y;
                const x1 = p1.x, x2 = p2.x;

                if ((y1 <= targetY && targetY <= y2) || (y2 <= targetY && targetY <= y1)) {
                    if (y1 === y2) {
                        intersections.push(x1, x2);
                    } else {
                        const slope = (x2 - x1) / (y2 - y1);
                        const x = x1 + (targetY - y1) * slope;
                        intersections.push(x);
                    }
                }
            }
            if (intersections.length === 0) return null;
            return side === 'right' ? Math.max(...intersections) : Math.min(...intersections);
        }

        function pointInPolygon(point, vs) {
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i].x, yi = vs[i].y;
                let xj = vs[j].x, yj = vs[j].y;
                
                let intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // =================================================================
        // 3. UI HANDLERS
        // =================================================================

        function setOutline(id) {
            currentOutlineId = id;
            const data = OUTLINE_DATA_SETS[id];
            
            if (data) {
                document.getElementById('input_L_outline').value = data.L;
                document.getElementById('input_B_outline').value = data.B;
                if(data.h_roll) PIVOT_POINT.y = data.h_roll;
                runCalculation();
            }
        }

        function updateToleranceInputs() {
            const scenarioKey = document.getElementById('track_scenario').value;
            const radiusKey = document.getElementById('radius_scenario').value;
            const data = TRACK_TOLERANCES[scenarioKey];
            
            if (data) {
                const lat = (radiusKey === 'gt_1000') ? data.lat_gt_1000 : data.lat_lte_1000;
                document.getElementById('input_tol_lat').value = lat;
                document.getElementById('input_tol_vert').value = data.vert;
                document.getElementById('input_tol_cant').value = data.cant;
                document.getElementById('input_tol_gw').value = data.gw;
            }
            runCalculation();
        }

        function runCalculation() {
            // 1. Gather Basic Inputs
            const R_meters = parseFloat(document.getElementById('input_R').value);
            const R_mm = R_meters * 1000;

            const L_veh = parseFloat(document.getElementById('input_L_veh').value);
            const B_veh = parseFloat(document.getElementById('input_B_veh').value);
            const h = parseFloat(document.getElementById('input_h').value);
            const w = parseFloat(document.getElementById('input_w').value);
            
            const L_outline = parseFloat(document.getElementById('input_L_outline').value);
            const B_outline = parseFloat(document.getElementById('input_B_outline').value);
            
            const isCW = document.getElementById('curve_cw').checked;
            let rollMag = parseFloat(document.getElementById('input_roll').value);
            const inputLat = parseFloat(document.getElementById('input_lat').value);
            let bounce = parseFloat(document.getElementById('input_bounce').value);
            const bounceYThreshold = parseFloat(document.getElementById('input_bounce_y').value);

            // --- 2. Track Tolerance Logic ---
            const useTolerances = document.getElementById('enable_tolerances').checked;
            const tolPanel = document.getElementById('tolerances_panel');
            
            let tolLatShift = 0; 
            let cantTolAngleDeg = 0;

            if (useTolerances) {
                tolPanel.classList.remove('opacity-50', 'pointer-events-none');
                
                // Read from manual override fields
                const t_lat = parseFloat(document.getElementById('input_tol_lat').value) || 0;
                const t_vert = parseFloat(document.getElementById('input_tol_vert').value) || 0;
                const t_cant = parseFloat(document.getElementById('input_tol_cant').value) || 0;
                const t_gw = parseFloat(document.getElementById('input_tol_gw').value) || 0;

                // Vertical Tolerance -> Adds to bounce
                bounce += t_vert;
                
                // Cant Tolerance -> Calculated as angle
                const cantAngleRad = t_cant / 1137;
                cantTolAngleDeg = degrees(cantAngleRad);
                
                // Gauge Widening + Lateral -> Adds to lateral both sides
                tolLatShift = t_lat + t_gw;

            } else {
                tolPanel.classList.add('opacity-50', 'pointer-events-none');
            }


            // 3. Calculate Throws (Kinematic)
            let calc_ET = 0, calc_CT = 0;
            let veh_ET = 0, veh_CT = 0;

            if (R_mm !== 0) {
                calc_ET = (Math.pow(L_outline, 2) - Math.pow(B_outline, 2)) / (8 * R_mm);
                calc_CT = Math.pow(B_outline, 2) / (8 * R_mm);

                veh_ET = (Math.pow(L_veh, 2) - Math.pow(B_veh, 2)) / (8 * R_mm);
                veh_CT = Math.pow(B_veh, 2) / (8 * R_mm);
            }

            // 4. Prepare Outline Data
            const dataset = OUTLINE_DATA_SETS[currentOutlineId];
            if(!dataset || !dataset.points) return;
            const rawPoints = dataset.points;
            
            // Calc bounce factor height
            const ys = rawPoints.map(p => p.y);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const vHeight = (maxY - minY) || 1;

            const polyCoords = { 
                left: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[], throw_type: ''}, 
                right: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[], throw_type: ''} 
            };

            // DEFINE ROLL ANGLES (ASYMMETRIC)
            // 1. Initial: Max roll applies to both directions (Envelope)
            // Left Lean (Positive), Right Lean (Negative)
            let rollLeftAngle = Math.abs(rollMag);
            let rollRightAngle = -Math.abs(rollMag);

            // 2. Apply Cant Tolerance (Directional only)
            // CW (Right Turn) -> Cant adds to Right Lean
            // CCW (Left Turn) -> Cant adds to Left Lean
            if (isCW) {
                // Right turn: Track banked right. Vehicle tilts further right.
                // Subtract cant from negative roll (making it more negative)
                rollRightAngle -= cantTolAngleDeg;
            } else {
                // Left turn: Track banked left. Vehicle tilts further left.
                // Add cant to positive roll
                rollLeftAngle += cantTolAngleDeg;
            }

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;

                // Determine Geometric Throw
                let throwVal = 0;
                let throwTypeLabel = '';

                if (isCW) {
                    if (side === 'left') { throwVal = calc_ET; throwTypeLabel = 'ET'; }
                    else { throwVal = calc_CT; throwTypeLabel = 'CT'; }
                } else {
                    if (side === 'left') { throwVal = calc_CT; throwTypeLabel = 'CT'; }
                    else { throwVal = calc_ET; throwTypeLabel = 'ET'; }
                }
                
                polyCoords[side].throw_type = throwTypeLabel;

                // Standard Lateral Shift (Play) - Post-Rotation
                // Right side gets +Lat, Left side gets -Lat
                const stdLatShift = (side === 'right') ? inputLat : -inputLat;

                // Tolerance Lateral Shift - Pre-Rotation (Expands outward on both sides)
                // If side is Right, we add positive. If Left, we add negative (move left).
                const preRotTolShift = (side === 'right') ? tolLatShift : -tolLatShift;

                for(let i=0; i<rawPoints.length-1; i++) {
                    const curr = rawPoints[i];
                    const next = rawPoints[i+1];
                    
                    const sx1 = curr.x * xMult, sy1 = curr.y;
                    const sx2 = next.x * xMult, sy2 = next.y;
                    
                    let b1 = (curr.y > bounceYThreshold) ? bounce : 0;
                    let b2 = (next.y > bounceYThreshold) ? bounce : 0;

                    const segPoints = [
                        {x: sx1, y: sy1, bounceOffset: b1},
                        {x: sx2, y: sy2, bounceOffset: b2}
                    ];
                    
                    segPoints.forEach(p => {
                        // 1. Original Static (Upright)
                        polyCoords[side].static_x.push(p.x);
                        polyCoords[side].static_y.push(p.y);

                        // 2. Rotated Static (Max Roll + Cant + Lateral Shift)
                        // Calculate both potential roll extremes to determine the outer envelope for the static line
                        const rotS_opt1 = getRotatedCoords(p.x, p.y, rollLeftAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        const rotS_opt2 = getRotatedCoords(p.x, p.y, rollRightAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        
                        let rotS;
                        if (side === 'right') {
                            rotS = (rotS_opt1.x > rotS_opt2.x) ? rotS_opt1 : rotS_opt2;
                        } else {
                            rotS = (rotS_opt1.x < rotS_opt2.x) ? rotS_opt1 : rotS_opt2;
                        }

                        polyCoords[side].rot_static_x.push(rotS.x + stdLatShift); 
                        polyCoords[side].rot_static_y.push(p.y);

                        // 3. DYNAMIC CALCULATION
                        
                        // A. Pre-Rotation Translation (Throw + Tolerance Lateral + Tolerance GW)
                        const x_pre = p.x + (throwVal * xMult) + preRotTolShift;
                        const y_pre = p.y + p.bounceOffset; // Bounce (includes vert tol)

                        // B. Rotation - Calculate BOTH extremes
                        const rotOpt1 = getRotatedCoords(x_pre, y_pre, rollLeftAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        const rotOpt2 = getRotatedCoords(x_pre, y_pre, rollRightAngle, PIVOT_POINT.x, PIVOT_POINT.y);

                        // Pick the one that pushes OUTWARDS for this side
                        let rot;
                        if (side === 'right') {
                            rot = (rotOpt1.x > rotOpt2.x) ? rotOpt1 : rotOpt2;
                        } else {
                            rot = (rotOpt1.x < rotOpt2.x) ? rotOpt1 : rotOpt2;
                        }

                        // C. Post-Rotation Translation (Standard Lateral Play/Bumpstop)
                        const final_x = rot.x + stdLatShift;
                        const final_y = y_pre; // Simplified Y (using input bounce logic, not strictly geometric drop from roll)

                        polyCoords[side].x.push(final_x);
                        polyCoords[side].y.push(final_y); 
                    });
                }
            });

            // 5. Calculate Study Points
            const h_bounced = h + ((h - minY) / vHeight) * bounce;
            const studyPoints = [];
            const results = [];

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;
                
                let ptThrowVal = 0;
                let ptThrowType = '';
                if (isCW) {
                    if (side === 'left') { ptThrowVal = veh_ET; ptThrowType = 'ET'; }
                    else { ptThrowVal = veh_CT; ptThrowType = 'CT'; }
                } else {
                    if (side === 'left') { ptThrowVal = veh_CT; ptThrowType = 'CT'; }
                    else { ptThrowVal = veh_ET; ptThrowType = 'ET'; }
                }

                const stdLatShift = (side === 'right') ? inputLat : -inputLat;
                const preRotTolShift = (side === 'right') ? tolLatShift : -tolLatShift;

                // A. Pre-Rotation
                const x_raw = (w/2 * xMult) + (ptThrowVal * xMult) + preRotTolShift;
                const y_pos = h_bounced;

                // B. Rotate (Envelope Logic)
                const p_r1 = getRotatedCoords(x_raw, y_pos, rollLeftAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                const p_r2 = getRotatedCoords(x_raw, y_pos, rollRightAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                
                let p_rot;
                if (side === 'right') {
                    p_rot = (p_r1.x > p_r2.x) ? p_r1 : p_r2;
                } else {
                    p_rot = (p_r1.x < p_r2.x) ? p_r1 : p_r2;
                }

                // C. Post-Rotation Shift
                const x_final = p_rot.x + stdLatShift;
                
                studyPoints.push({
                    x: x_final, 
                    y: y_pos, 
                    side: side,
                    type: ptThrowType,
                    color: (ptThrowType === 'ET' ? '#059669' : '#d946ef')
                });

                const y_check = y_pos; 

                // --- Calculate Deltas ---
                const rotStaticPts = polyCoords[side].rot_static_x.map((x, i) => ({x: x, y: polyCoords[side].rot_static_y[i]}));
                const rotStaticX = getXAtY(y_check, rotStaticPts, side);
                
                const origStaticPts = polyCoords[side].static_x.map((x, i) => ({x: x, y: polyCoords[side].static_y[i]}));
                const origStaticX = getXAtY(y_check, origStaticPts, side);

                const envPts = polyCoords[side].x.map((x, i) => ({x: x, y: polyCoords[side].y[i]}));
                const envX = getXAtY(y_check, envPts, side);

                results.push({ 
                    side: side, 
                    throwType: ptThrowType,
                    p: {x: p_rot.x, y: y_pos}, 
                    rotStaticX: rotStaticX, 
                    origStaticX: origStaticX, 
                    envX: envX 
                });
            });

            // 6. Draw
            draw(polyCoords, studyPoints, results, {
                roll: rollMag, 
                cant: cantTolAngleDeg,
                lat: inputLat, 
                tolLat: tolLatShift,
                bounce, 
                isCW,
                tolerancesActive: useTolerances
            });
        }

        // =================================================================
        // 4. DRAWING
        // =================================================================

        function draw(polyCoords, studyPoints, results, params) {
            const canvas = document.getElementById('plotCanvas');
            const ctx = canvas.getContext('2d');
            
            const parent = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = parent.clientWidth * dpr;
            canvas.height = parent.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const width = parent.clientWidth;
            const height = parent.clientHeight;
            ctx.clearRect(0, 0, width, height);

            // --- Scaling ---
            let allX = [], allY = [];
            allX.push(PIVOT_POINT.x); allY.push(PIVOT_POINT.y);
            ['right', 'left'].forEach(s => {
                allX.push(...polyCoords[s].x, ...polyCoords[s].static_x, ...polyCoords[s].rot_static_x);
                allY.push(...polyCoords[s].y, ...polyCoords[s].static_y);
            });
            studyPoints.forEach(sp => { allX.push(sp.x); allY.push(sp.y); });

            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);

            const marginX = 800; 
            const marginY = 800;
            const dataW = (maxX - minX) + marginX * 2;
            const dataH = (maxY - minY) + marginY * 2;
            
            const plotXStart = 60; 
            const plotYStart = 60; 
            const plotW = width - plotXStart - 20; 
            const plotH = height - plotYStart - 40; 

            const scaleX = plotW / dataW;
            const scaleY = plotH / dataH;
            const scale = Math.min(scaleX, scaleY);

            const dataCx = (minX + maxX) / 2;
            const dataCy = (minY + maxY) / 2;

            const cx = plotXStart + plotW / 2;
            const cy = plotYStart + plotH / 2;

            function toScreen(x, y) {
                return {
                    x: cx + (x - dataCx) * scale,
                    y: cy - (y - dataCy) * scale 
                };
            }

            // --- Grid ---
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,width,height);

            ctx.save();
            ctx.strokeStyle = '#e5e7eb'; 
            ctx.lineWidth = 0.8;
            ctx.setLineDash([4, 4]); 
            
            const gridSize = 500; 
            const startGridX = Math.floor((minX - marginX)/gridSize)*gridSize;
            const endGridX = Math.ceil((maxX + marginX)/gridSize)*gridSize;
            const startGridY = Math.floor((minY - marginY)/gridSize)*gridSize;
            const endGridY = Math.ceil((maxY + marginY)/gridSize)*gridSize;

            ctx.font = '10px Arial';
            ctx.fillStyle = '#9ca3af';

            ctx.textAlign = 'center';
            for(let gx = startGridX; gx <= endGridX; gx += gridSize) {
                const p = toScreen(gx, 0);
                if(p.x >= plotXStart && p.x <= width) {
                    ctx.beginPath(); ctx.moveTo(p.x, plotYStart); ctx.lineTo(p.x, height - 20); ctx.stroke();
                    if(gx % 1000 === 0) ctx.fillText(gx, p.x, height - 5);
                }
            }
            ctx.textAlign = 'right';
            for(let gy = startGridY; gy <= endGridY; gy += gridSize) {
                const p = toScreen(0, gy);
                if(p.y >= plotYStart && p.y <= height - 20) {
                    ctx.beginPath(); ctx.moveTo(plotXStart, p.y); ctx.lineTo(width, p.y); ctx.stroke();
                    if(gy % 1000 === 0) ctx.fillText(gy, plotXStart - 5, p.y + 3);
                }
            }
            ctx.restore();

            // Axis Titles
            ctx.save();
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("x (mm)", plotXStart + plotW/2, height - 5);
            ctx.translate(15, plotYStart + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("y (mm)", 0, 0);
            ctx.restore();

            // --- 1. Draw Original Static Vehicle (Solid Blue) ---
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1.0; 
            ctx.setLineDash([]);
            ctx.beginPath();
            
            ['left', 'right'].forEach(s => {
                const pts = polyCoords[s].static_x.map((x, i) => ({x, y: polyCoords[s].static_y[i]}));
                if(pts.length) {
                    const st = toScreen(pts[0].x, pts[0].y);
                    ctx.moveTo(st.x, st.y);
                    for(let i=1; i<pts.length; i++) {
                        const p = toScreen(pts[i].x, pts[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                }
            });
            ctx.stroke();

            // --- 2. Draw Rotated Static Vehicle (Dotted Blue + Shaded) ---
            const rotPoly = [];
            polyCoords.left.rot_static_x.forEach((x, i) => rotPoly.push({x: x, y: polyCoords.left.rot_static_y[i]}));
            for(let i = polyCoords.right.rot_static_x.length - 1; i >= 0; i--) {
                rotPoly.push({x: polyCoords.right.rot_static_x[i], y: polyCoords.right.rot_static_y[i]});
            }

            ctx.save();
            ctx.beginPath();
            if(rotPoly.length) {
                const s = toScreen(rotPoly[0].x, rotPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<rotPoly.length; i++) {
                    const p = toScreen(rotPoly[i].x, rotPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }
            ctx.fillStyle = 'rgba(59, 130, 246, 0.15)'; 
            ctx.fill();
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([2, 3]);
            ctx.stroke();
            ctx.restore();

            // --- 3. Construct Dynamic Envelope Polygon ---
            const fullPoly = [];
            polyCoords.left.x.forEach((x, i) => fullPoly.push({x: x, y: polyCoords.left.y[i]}));
            for(let i = polyCoords.right.x.length - 1; i >= 0; i--) {
                fullPoly.push({x: polyCoords.right.x[i], y: polyCoords.right.y[i]});
            }

            let globalStatus = 'PASS'; 
            const TOLERANCE_MM = 1e-9;
            
            if (fullPoly.length > 0 && studyPoints.length > 0) {
                let hasFail = false;
                let hasBoundary = false;
                studyPoints.forEach((sp, idx) => {
                    const isStrictlyInside = pointInPolygon(sp, fullPoly);
                    const res = results[idx];
                    let isLocalBoundary = false;
                    if (res && res.envX !== null) {
                         const dist = Math.abs(sp.x - res.envX);
                         if (dist <= TOLERANCE_MM) {
                             hasBoundary = true;
                             isLocalBoundary = true;
                         }
                    }
                    if (!isLocalBoundary && !isStrictlyInside) hasFail = true;
                });
                if (hasFail) globalStatus = 'FAIL';
                else if (hasBoundary) globalStatus = 'BOUNDARY';
            }

            // --- 4. Draw Dynamic Envelope ---
            ctx.beginPath();
            if(fullPoly.length) {
                const s = toScreen(fullPoly[0].x, fullPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<fullPoly.length; i++) {
                    const p = toScreen(fullPoly[i].x, fullPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }
            if (globalStatus === 'FAIL') ctx.fillStyle = 'rgba(254, 202, 202, 0.4)'; // Red
            else if (globalStatus === 'BOUNDARY') ctx.fillStyle = 'rgba(251, 191, 36, 0.4)'; // Amber
            else ctx.fillStyle = 'rgba(230, 249, 230, 0.4)'; // Green
            ctx.fill();
            ctx.strokeStyle = '#FF6347'; // Tomato
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Pivot
            const piv = toScreen(PIVOT_POINT.x, PIVOT_POINT.y);
            ctx.fillStyle = 'black'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
            const plusSize = 6;
            ctx.beginPath();
            ctx.moveTo(piv.x - plusSize, piv.y); ctx.lineTo(piv.x + plusSize, piv.y);
            ctx.moveTo(piv.x, piv.y - plusSize); ctx.lineTo(piv.x, piv.y + plusSize);
            ctx.stroke();

            // --- Draw Study Points & Annotations (BOTH SIDES) ---
            studyPoints.forEach((sp, idx) => {
                const scr = toScreen(sp.x, sp.y);
                
                // Marker
                ctx.strokeStyle = sp.color || '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(scr.x - 4, scr.y); ctx.lineTo(scr.x + 4, scr.y);
                ctx.moveTo(scr.x, scr.y - 4); ctx.lineTo(scr.x, scr.y + 4);
                ctx.stroke();

                // Annotations
                const res = results[idx];
                const isLeft = (sp.side === 'left');
                const textAlign = isLeft ? 'right' : 'left';
                const textXOffset = isLeft ? -10 : 10;
                
                // Y label
                ctx.font = '11px Arial';
                ctx.fillStyle = '#008000';
                ctx.textAlign = textAlign;
                ctx.fillText(`y:${sp.y.toFixed(0)}`, scr.x + textXOffset, scr.y - 30);

                // X drop line
                const axisY = height - 20; 
                ctx.save();
                ctx.setLineDash([2, 2]);
                ctx.strokeStyle = '#008000'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(scr.x, scr.y); ctx.lineTo(scr.x, axisY); ctx.stroke();
                ctx.restore();
                ctx.textAlign = 'center';
                ctx.fillText(`${sp.x.toFixed(0)}`, scr.x, height - 5);

                // --- Delta Lines ---

                // A. NEW: Shift Delta (Blue Dashed) - Distance between Original Static and Rotated Static
                if(res.rotStaticX !== null && res.origStaticX !== null) {
                    const rotScr = toScreen(res.rotStaticX, sp.y);
                    const origScr = toScreen(res.origStaticX, sp.y);
                    const dist = Math.abs(res.rotStaticX - res.origStaticX);

                    // Only draw if there is a meaningful distance
                    if (dist > 0.5) {
                        // Draw line between them
                        ctx.beginPath(); 
                        ctx.strokeStyle = '#2563eb'; // Blue like the static outlines
                        ctx.lineWidth = 1; 
                        ctx.setLineDash([2, 2]);
                        ctx.moveTo(origScr.x, origScr.y); 
                        ctx.lineTo(rotScr.x, rotScr.y); 
                        ctx.stroke();

                        // Draw dots at ends
                        ctx.fillStyle = '#2563eb';
                        ctx.beginPath(); ctx.arc(origScr.x, origScr.y, 2, 0, 2*Math.PI); ctx.fill();
                        ctx.beginPath(); ctx.arc(rotScr.x, rotScr.y, 2, 0, 2*Math.PI); ctx.fill();

                        // Label
                        const midX = (rotScr.x + origScr.x) / 2;
                        ctx.font = '10px Arial';
                        ctx.fillStyle = '#1d4ed8'; // Darker blue
                        ctx.textAlign = 'center';
                        ctx.fillText(`Shift: ${dist.toFixed(1)}`, midX, scr.y - 18); 
                    }
                }
                
                // B. Static Delta (Red Dotted) - Distance to Rotated Static
                if(res.rotStaticX !== null) {
                    const statScr = toScreen(res.rotStaticX, sp.y);
                    ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.lineWidth = 1.5; ctx.setLineDash([2, 2]);
                    ctx.moveTo(statScr.x, statScr.y); ctx.lineTo(scr.x, scr.y); ctx.stroke();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(statScr.x, statScr.y, 2, 0, 2*Math.PI); ctx.fill();

                    // Text: Dynamic Label (ET vs CT)
                    const dist = Math.abs(sp.x - res.rotStaticX);
                    ctx.font = 'bold 11px Arial';
                    ctx.fillStyle = 'red';
                    ctx.textAlign = textAlign;
                    ctx.fillText(`Δ ${res.throwType} Static: ${dist.toFixed(1)}`, scr.x + textXOffset, scr.y - 18);
                }

                // C. Env Delta Line (Purple Dashed)
                if(res.envX !== null) {
                    const envScr = toScreen(res.envX, sp.y);
                    ctx.beginPath(); ctx.strokeStyle = '#800080'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
                    ctx.moveTo(envScr.x, envScr.y); ctx.lineTo(scr.x, scr.y); ctx.stroke();
                    
                    const dist = Math.abs(sp.x - res.envX);
                    ctx.font = 'bold 11px Arial';
                    ctx.fillStyle = '#4B0082';
                    ctx.textAlign = textAlign;
                    ctx.fillText(`Δ Env: ${dist.toFixed(1)}`, scr.x + textXOffset, scr.y - 6);
                }
            });

            // --- TITLE BLOCK ---
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            const dirText = params.isCW ? "Clockwise (Right Turn)" : "Counter-Clockwise (Left Turn)";
            ctx.fillText(`Vehicle Outline Simulation - ${dirText}`, cx, 20);
            
            ctx.font = '14px Arial';
            let statusText = "PASS (Inside)";
            if (globalStatus === 'FAIL') statusText = "FAIL (Outside)";
            else if (globalStatus === 'BOUNDARY') statusText = "BOUNDARY (On Line)";
            
            let tolText = params.tolerancesActive ? ` | Tol Lat: ±${params.tolLat}mm | Cant Tol: ${params.cant.toFixed(2)}°` : "";
            ctx.fillText(`Status: ${statusText} | Roll: ±${Math.abs(params.roll).toFixed(2)}° | Play: ±${params.lat.toFixed(1)}mm${tolText}`, cx, 40);
            ctx.restore();

            // --- LEGEND ---
            drawLegend(ctx, width - 130, 10);
        }

        function drawLegend(ctx, x, y) {
            const w = 120;
            const h = 150; 
            ctx.save();
            ctx.fillStyle = 'white'; ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
            ctx.fillRect(x, y, w, h); ctx.strokeRect(x, y, w, h);

            const items = [
                { color: 'black', text: 'Pivot (0, 1100)', type: 'symbol', symbol: '+' },
                { color: 'rgba(230, 249, 230, 1)', text: 'Dynamic Env', type: 'rect' },
                { color: 'rgba(59, 130, 246, 0.4)', text: 'Static (Rotated)', type: 'dottedRect' },
                { color: '#2563eb', text: 'Original Static', type: 'line' },
                { color: '#008000', text: 'Point (ET/CT)', type: 'symbol', symbol: '+' },
                { color: '#2563eb', text: 'Shift (Lat+Roll)', type: 'dashed' }, 
                { color: 'red', text: 'Δ Static (Red)', type: 'dashed' },
                { color: '#800080', text: 'Δ Env (Purple)', type: 'dashed' },
            ];

            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let cy = y + 10;
            const lx = x + 10;
            const tx = x + 25;

            items.forEach(item => {
                ctx.fillStyle = 'black'; ctx.fillText(item.text, tx, cy);
                if(item.type === 'line') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 1.5; ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'dashed') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 1.5; ctx.setLineDash([3, 2]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'rect') {
                    ctx.fillStyle = item.color; ctx.strokeStyle = '#FF6347'; ctx.setLineDash([2,1]); ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6); ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'dottedRect') {
                    ctx.fillStyle = item.color; ctx.strokeStyle = '#2563eb'; ctx.setLineDash([1,2]); ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6); ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'symbol') {
                    ctx.strokeStyle = item.color; ctx.lineWidth = 2; ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(lx-3, cy); ctx.lineTo(lx+3, cy);
                    ctx.moveTo(lx, cy-3); ctx.lineTo(lx, cy+3);
                    ctx.stroke();
                }
                cy += 15;
            });
            ctx.restore();
        }

        document.querySelectorAll('input, select').forEach(inp => {
            inp.addEventListener('input', runCalculation);
            inp.addEventListener('change', runCalculation);
        });
        window.addEventListener('resize', runCalculation);
        window.onload = function() {
            setOutline('RS4.1');
            updateToleranceInputs(); // Initialize inputs
        };

    </script>
</body>
</html>
