<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Throw & Clearance Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas and inputs */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .input-group {
            @apply border border-gray-400 p-2 mb-4 rounded bg-white;
        }
        .input-row {
            @apply flex items-center gap-2 mb-2 text-sm;
        }
        .input-label {
            @apply w-32 font-medium text-gray-700;
        }
        .input-field {
            @apply border border-gray-300 rounded px-2 py-1 w-24 text-right focus:outline-none focus:border-blue-500;
        }
        .section-header {
            @apply font-bold text-gray-800 mb-2 border-b border-gray-200 pb-1;
        }
        /* Custom radio button styling */
        input[type="radio"] {
            accent-color: #2563eb; 
            transform: scale(1.2);
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-gray-800 h-screen w-screen overflow-hidden flex flex-col">

    <!-- MAIN LAYOUT CONTAINER (Full Width/Height) -->
    <div class="flex-1 grid grid-cols-1 lg:grid-cols-12 h-full w-full">
        
        <!-- CONTROL PANEL (Scrollable Sidebar) -->
        <div class="lg:col-span-3 h-full overflow-y-auto p-4 border-r border-gray-200 bg-gray-50 z-10 shadow-sm">
            
            <h1 class="text-xl font-bold mb-4 text-gray-900">Input Parameters</h1>

            <div class="input-group">
                <div class="input-row">
                    <input type="radio" name="rad_sel" checked class="mr-2">
                    <span class="font-bold mr-auto">Radius (R) [m]</span>
                    <input type="number" id="input_R" value="100" class="input-field w-32">
                </div>
            </div>

            <div class="input-group">
                <div class="flex items-center gap-2 mb-1">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_L_veh" class="text-xs font-bold text-gray-500 w-12 text-right">L_veh</label>
                        <input type="number" id="input_L_veh" class="input-field w-full" value="21000">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_B_veh" class="text-xs font-bold text-gray-500 w-12 text-right">B_veh</label>
                        <input type="number" id="input_B_veh" class="input-field w-full" value="15850">
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_h" class="text-xs font-bold text-gray-500 w-12 text-right">h</label>
                        <input type="number" id="input_h" class="input-field w-full" value="400">
                    </div>
                    <div class="flex-1 flex items-center gap-1">
                        <label for="input_w" class="text-xs font-bold text-gray-500 w-12 text-right">w</label>
                        <input type="number" id="input_w" class="input-field w-full" value="2540">
                    </div>
                </div>
            </div>

            <div class="input-group">
                <!-- Header with explicit column widths to match rows -->
                <div class="flex items-center gap-2 mb-2 px-1 text-xs font-bold text-gray-500">
                    <span class="w-6"></span> <!-- Space for Radio -->
                    <span class="flex-1">Outline</span>
                    <span class="w-12 text-center">ID</span>
                    <span class="w-16 text-center">L</span>
                    <span class="w-16 text-center">B</span>
                </div>

                <div class="space-y-1">
                    <!-- Row 1 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs1" class="w-4 h-4 cursor-pointer" onchange="setOutline(1, 16200, 11000)">
                        <label for="rs1" class="flex-1 cursor-pointer font-medium text-sm">RS1</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:1</span>
                        <span class="w-16"></span> <!-- Empty L spacer -->
                        <span class="w-16"></span> <!-- Empty B spacer -->
                    </div>
                    <!-- Row 2 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs2" class="w-4 h-4 cursor-pointer" onchange="setOutline(2, 19150, 14000)">
                        <label for="rs2" class="flex-1 cursor-pointer font-medium text-sm">RS2</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:2</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                    <!-- Row 3 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs3" class="w-4 h-4 cursor-pointer" onchange="setOutline(3, 19150, 14000)">
                        <label for="rs3" class="flex-1 cursor-pointer font-medium text-sm">RS3</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:3</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                    <!-- Row 4 -->
                    <div class="flex items-center gap-2 hover:bg-gray-50 p-1 rounded">
                        <input type="radio" name="outline_sel" id="rs4" class="w-4 h-4 cursor-pointer" checked onchange="setOutline(4, 21000, 15850)">
                        <label for="rs4" class="flex-1 cursor-pointer font-medium text-sm">RS4</label>
                        <span class="w-12 text-center text-xs text-gray-400">ID:4</span>
                        <span class="w-16"></span>
                        <span class="w-16"></span>
                    </div>
                </div>

                <!-- Active inputs with Labels explicitly beside them -->
                <div class="border-t border-gray-200 mt-2 pt-2 flex items-center gap-2">
                    <div class="text-xs font-bold text-gray-500 w-12">Active:</div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">L</span>
                         <input type="number" id="input_L_outline" class="input-field w-full" value="21000">
                    </div>
                    
                    <div class="flex-1 flex items-center gap-1">
                         <span class="text-xs font-bold text-gray-400">B</span>
                         <input type="number" id="input_B_outline" class="input-field w-full" value="15850">
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div class="section-header">Study Type</div>
                <div class="input-row">
                    <input type="radio" name="study_type" id="study1" value="1" checked class="mr-2" onchange="runCalculation()">
                    <label for="study1" class="flex-1 cursor-pointer">End Throw</label>
                    <span class="bg-gray-100 text-gray-600 px-2 rounded text-xs">ID: 1</span>
                </div>
                <div class="input-row">
                    <input type="radio" name="study_type" id="study2" value="2" class="mr-2" onchange="runCalculation()">
                    <label for="study2" class="flex-1 cursor-pointer">Centre Throw</label>
                    <span class="bg-gray-100 text-gray-600 px-2 rounded text-xs">ID: 2</span>
                </div>
            </div>

            <div class="input-group">
                <div class="flex justify-between mb-2 px-2 text-xs font-bold text-gray-500">
                    <span class="w-20 text-center">Roll (deg)</span>
                    <span class="w-20 text-center">Lat (mm)</span>
                    <span class="w-20 text-center">Bounce (mm)</span>
                </div>
                <div class="input-row">
                    <input type="radio" checked disabled class="mr-2 opacity-50">
                    <label class="flex-1 text-sm">Parameters</label>
                </div>
                <div class="grid grid-cols-3 gap-2 pt-1">
                    <input type="number" id="input_roll" class="input-field w-full" value="1.25" step="0.1">
                    <input type="number" id="input_lat" class="input-field w-full" value="43">
                    <input type="number" id="input_bounce" class="input-field w-full" value="50">
                </div>
            </div>
            
            <button onclick="runCalculation()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow mt-2">
                Calculate & Plot
            </button>

             <!-- Removed text-based output, moved to canvas -->
             <div class="mt-4 text-xs text-gray-400 text-center">
                 Calculated values are now displayed directly on the graph.
             </div>

        </div>

        <!-- VISUALIZATION PANEL (Fills Remaining Space) -->
        <div class="lg:col-span-9 h-full p-4 flex flex-col bg-gray-50 overflow-hidden">
            <div class="bg-white rounded-lg shadow-lg p-1 border border-gray-200 flex-1 flex flex-col relative overflow-hidden">
                <!-- Canvas Container takes full height/width -->
                <div class="relative w-full h-full">
                    <canvas id="plotCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // 1. DATA & CONSTANTS
        // =================================================================
        
        const PIVOT_POINT = { x: 0, y: 1100 };

        // Parsed Outline Data
        const OUTLINE_DATA_SETS = {
            1: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1220,y:535,type:1}, {x:1220,y:825,type:1}, {x:1315,y:915,type:1},
                {x:1425,y:915,type:1}, 
                {x:1425,y:3250,type:2, cx:-328, cy:1468, r:2500},
                {x:250,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            2: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1450,y:915,type:1}, {x:1450,y:2845,type:1}, {x:1412,y:3415,type:1},
                {x:1040,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            3: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1450,y:915,type:1}, {x:1450,y:2845,type:1}, {x:1400,y:3600,type:1},
                {x:1080,y:3900,type:1}, {x:0,y:3900,type:1}
            ],
            4: [
                {x:0,y:65,type:1}, {x:1195,y:65,type:1}, {x:1245,y:180,type:1},
                {x:1245,y:305,type:1}, {x:1270,y:305,type:1}, {x:1270,y:535,type:1},
                {x:1245,y:535,type:1}, {x:1245,y:845,type:1}, {x:1315,y:915,type:1},
                {x:1430,y:915,type:1}, {x:1430,y:1850,type:1}, {x:1350,y:3250,type:1},
                {x:1000,y:3584.9943,type:2, cx:-328, cy:1468, r:2500},
                {x:247,y:3900,type:1}, {x:0,y:3900,type:1}
            ]
        };

        let currentOutlineId = 4;

        // =================================================================
        // 2. MATH HELPERS
        // =================================================================

        function radians(deg) { return deg * Math.PI / 180; }

        function getRotatedCoords(x, y, angleDeg, cx, cy) {
            const rad = radians(angleDeg);
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            const dx = x - cx;
            const dy = y - cy;
            return {
                x: cx + dx * c - dy * s,
                y: cy + dx * s + dy * c
            };
        }

        function getArcPoints(pStart, pEnd, cx, cy, radius, numPoints = 20) {
            let startAngle = Math.atan2(pStart.y - cy, pStart.x - cx);
            let endAngle = Math.atan2(pEnd.y - cy, pEnd.x - cx);

            // Handle wrapping across PI/-PI boundary
            if (Math.abs(endAngle - startAngle) > Math.PI) {
                if (endAngle > startAngle) startAngle += 2 * Math.PI;
                else endAngle += 2 * Math.PI;
            }

            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = startAngle + (endAngle - startAngle) * (i / numPoints);
                points.push({
                    x: cx + radius * Math.cos(t),
                    y: cy + radius * Math.sin(t)
                });
            }
            return points;
        }

        // Linear interpolation to find X at a given Y
        function getXAtY(targetY, polyPoints, side = 'right') {
            const intersections = [];
            for (let i = 0; i < polyPoints.length - 1; i++) {
                const p1 = polyPoints[i];
                const p2 = polyPoints[i+1];

                const y1 = p1.y, y2 = p2.y;
                const x1 = p1.x, x2 = p2.x;

                // Check interval
                if ((y1 <= targetY && targetY <= y2) || (y2 <= targetY && targetY <= y1)) {
                    if (y1 === y2) {
                        intersections.push(x1, x2);
                    } else {
                        const slope = (x2 - x1) / (y2 - y1);
                        const x = x1 + (targetY - y1) * slope;
                        intersections.push(x);
                    }
                }
            }

            if (intersections.length === 0) return null;
            return side === 'right' ? Math.max(...intersections) : Math.min(...intersections);
        }

        // Point inside polygon (Ray casting)
        function pointInPolygon(point, vs) {
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i].x, yi = vs[i].y;
                let xj = vs[j].x, yj = vs[j].y;
                
                let intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // =================================================================
        // 3. UI HANDLERS
        // =================================================================

        function setVehicle(L, B, h, w) {
            document.getElementById('input_L_veh').value = L;
            document.getElementById('input_B_veh').value = B;
            document.getElementById('input_h').value = h;
            document.getElementById('input_w').value = w;
            runCalculation();
        }

        function setOutline(id, L, B) {
            currentOutlineId = id;
            document.getElementById('input_L_outline').value = L;
            document.getElementById('input_B_outline').value = B;
            runCalculation();
        }

        function runCalculation() {
            // 1. Gather Inputs
            const R_meters = parseFloat(document.getElementById('input_R').value);
            const R_mm = R_meters * 1000;

            const L_veh = parseFloat(document.getElementById('input_L_veh').value);
            const B_veh = parseFloat(document.getElementById('input_B_veh').value);
            const h = parseFloat(document.getElementById('input_h').value);
            const w = parseFloat(document.getElementById('input_w').value);
            
            const L_outline = parseFloat(document.getElementById('input_L_outline').value);
            const B_outline = parseFloat(document.getElementById('input_B_outline').value);
            
            const studyType = parseInt(document.querySelector('input[name="study_type"]:checked').value);
            const roll = parseFloat(document.getElementById('input_roll').value);
            const lat = parseFloat(document.getElementById('input_lat').value);
            const bounce = parseFloat(document.getElementById('input_bounce').value);

            // 2. Calculate Throws
            let calc_ET = 0, calc_CT = 0;
            let veh_ET = 0, veh_CT = 0;

            if (R_mm !== 0) {
                // Formula: (L^2 - B^2) / 8R  (All units must be same, usually mm)
                
                // Active Outline
                calc_ET = (Math.pow(L_outline, 2) - Math.pow(B_outline, 2)) / (8 * R_mm);
                calc_CT = Math.pow(B_outline, 2) / (8 * R_mm);

                // Input Vehicle
                veh_ET = (Math.pow(L_veh, 2) - Math.pow(B_veh, 2)) / (8 * R_mm);
                veh_CT = Math.pow(B_veh, 2) / (8 * R_mm);
            }

            // 3. Prepare Outline Data
            const rawPoints = OUTLINE_DATA_SETS[currentOutlineId];
            if(!rawPoints) return;

            // Find min/max y for normalization
            const ys = rawPoints.map(p => p.y);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const vHeight = (maxY - minY) || 1;
            
            // 4. Generate Polygons
            // Added rot_static_x/y for the rotated static outline
            const polyCoords = { 
                left: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[]}, 
                right: {x:[], y:[], static_x:[], static_y:[], rot_static_x:[], rot_static_y:[]} 
            };

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;
                const tiltAngle = (side === 'right') ? -roll : roll;
                const throwVal = (studyType === 1) ? calc_ET : ((studyType === 2) ? calc_CT : 0);

                // We need to iterate segments
                for(let i=0; i<rawPoints.length-1; i++) {
                    const curr = rawPoints[i];
                    const next = rawPoints[i+1];
                    
                    const sx1 = curr.x * xMult, sy1 = curr.y;
                    const sx2 = next.x * xMult, sy2 = next.y;
                    
                    let segPoints = [];
                    // Generate points for this segment (Static)
                    if(curr.type === 1) {
                        segPoints.push({x: sx1, y: sy1});
                        segPoints.push({x: sx2, y: sy2});
                    } else if(curr.type === 2) {
                        const cx = curr.cx * xMult;
                        const arcPts = getArcPoints({x:sx1, y:sy1}, {x:sx2, y:sy2}, cx, curr.cy, curr.r);
                        segPoints = arcPts;
                    }
                    
                    // Store Static (Flattened)
                    segPoints.forEach(p => {
                        // 1. Original Static (Upright)
                        polyCoords[side].static_x.push(p.x);
                        polyCoords[side].static_y.push(p.y);

                        // 2. Rotated Static (Tilted but on floor Y=65)
                        // Rotate p.x, p.y around Pivot
                        const rotS = getRotatedCoords(p.x, p.y, tiltAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        // Use Rotated X, but Original Y
                        polyCoords[side].rot_static_x.push(rotS.x);
                        polyCoords[side].rot_static_y.push(p.y);
                    });

                    // Transform for Dynamic (Throw Loop)
                    segPoints.forEach(p => {
                        // Apply Throw + Lat + Bounce
                        // tx = x + (lat + throw) * direction
                        
                        const tx = p.x + (lat + throwVal) * xMult;
                        
                        // ty = y + normalized_height * bounce
                        const normH = (p.y - minY) / vHeight;
                        const ty = p.y + normH * bounce;

                        // Rotate
                        const rot = getRotatedCoords(tx, ty, tiltAngle, PIVOT_POINT.x, PIVOT_POINT.y);
                        
                        // FIX: Use rotated X, but un-rotated Y (ty)
                        polyCoords[side].x.push(rot.x);
                        polyCoords[side].y.push(ty); 
                    });
                }
            });

            // 5. Calculate Study Points (The points we check for clearance)
            const h_bounced = h + ((h - minY) / vHeight) * bounce;
            const studyPoints = [];
            const results = [];

            ['right', 'left'].forEach(side => {
                const xMult = (side === 'right') ? 1 : -1;
                const tilt = (side === 'right') ? -roll : roll;
                
                // Which throw value to use for the POINT location?
                const pointThrowVal = (studyType === 1) ? veh_ET : veh_CT;
                
                // Calculate raw position before rotation
                // x = (lat + w/2 + offset) * side
                const x_raw = (lat + (w/2) + pointThrowVal) * xMult;
                const y_pos = h_bounced;

                // Rotate
                const p_rot = getRotatedCoords(x_raw, y_pos, tilt, PIVOT_POINT.x, PIVOT_POINT.y);
                
                // FIX: Use rotated X, but un-rotated Y (y_pos) for the study point
                studyPoints.push({
                    x: p_rot.x, 
                    y: y_pos, // Kept unrotated per user request
                    side: side,
                    color: (studyType === 1 ? '#059669' : '#d946ef') // Green or Magenta
                });

                // Note: p_rot.y in results calculation below should also use unrotated Y if we want consistency for "Clearance" check
                const y_check = y_pos; 

                // --- Calculate Deltas ---
                
                // 1. Static Delta (Distance from Study Point to Rotated Static)
                const rotStaticPts = polyCoords[side].rot_static_x.map((x, i) => ({x: x, y: polyCoords[side].rot_static_y[i]}));
                const rotStaticX = getXAtY(y_check, rotStaticPts, side);
                
                // 2. Origin Delta (Distance from Rotated Static to Original Static)
                const origStaticPts = polyCoords[side].static_x.map((x, i) => ({x: x, y: polyCoords[side].static_y[i]}));
                const origStaticX = getXAtY(y_check, origStaticPts, side);

                // 3. Envelope Delta
                const envPts = polyCoords[side].x.map((x, i) => ({x: x, y: polyCoords[side].y[i]}));
                const envX = getXAtY(y_check, envPts, side);

                let res = { 
                    side: side, 
                    p: {x: p_rot.x, y: y_pos}, 
                    rotStaticX: rotStaticX, // X on rotated static line
                    origStaticX: origStaticX, // X on upright static line
                    envX: envX 
                };
                results.push(res);
            });

            // 6. Draw
            draw(polyCoords, studyPoints, results, {roll, lat, bounce, studyType});
        }

        // =================================================================
        // 4. DRAWING
        // =================================================================

        function draw(polyCoords, studyPoints, results, params) {
            const canvas = document.getElementById('plotCanvas');
            const ctx = canvas.getContext('2d');
            
            // Responsive sizing - check parent
            const parent = canvas.parentElement;
            
            // High DPI (Retina) scaling logic
            const dpr = window.devicePixelRatio || 1;
            
            // Set the canvas internal resolution to match screen density
            canvas.width = parent.clientWidth * dpr;
            canvas.height = parent.clientHeight * dpr;
            
            // Scale all drawing operations by dpr
            ctx.scale(dpr, dpr);

            // Use logical CSS pixels for width/height variables so the rest of the math works as expected
            const width = parent.clientWidth;
            const height = parent.clientHeight;

            ctx.clearRect(0, 0, width, height);

            // --- Coordinate System Setup ---
            // Auto-scale to fit
            // Gather all points (static + dynamic) to find bounds
            let allX = [], allY = [];
            
            // Add pivot
            allX.push(PIVOT_POINT.x); allY.push(PIVOT_POINT.y);

            ['right', 'left'].forEach(s => {
                allX.push(...polyCoords[s].x, ...polyCoords[s].static_x, ...polyCoords[s].rot_static_x);
                allY.push(...polyCoords[s].y, ...polyCoords[s].static_y);
            });
            
            // Add study points
            studyPoints.forEach(sp => { allX.push(sp.x); allY.push(sp.y); });

            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);

            // Add margin (Technical chart needs more margin for axes)
            const marginX = 800; 
            const marginY = 800;
            const dataW = (maxX - minX) + marginX * 2;
            const dataH = (maxY - minY) + marginY * 2;
            
            // Scale
            // Adjust scale to leave room for Title (top) and Axis (left/bottom)
            const plotXStart = 60; // Left padding for Y axis labels
            const plotYStart = 60; // Top padding for Title
            const plotW = width - plotXStart - 20; // Right padding
            const plotH = height - plotYStart - 40; // Bottom padding for X axis labels

            const scaleX = plotW / dataW;
            const scaleY = plotH / dataH;
            const scale = Math.min(scaleX, scaleY);

            const dataCx = (minX + maxX) / 2;
            const dataCy = (minY + maxY) / 2;

            const cx = plotXStart + plotW / 2;
            const cy = plotYStart + plotH / 2;

            function toScreen(x, y) {
                // Flip Y for canvas
                return {
                    x: cx + (x - dataCx) * scale,
                    y: cy - (y - dataCy) * scale 
                };
            }

            // --- Background & Grid ---
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,width,height);

            // Grid Lines
            ctx.save();
            ctx.strokeStyle = '#d1d5db'; // Light gray
            ctx.lineWidth = 0.8;
            ctx.setLineDash([4, 4]); // Dashed grid
            
            const gridSize = 500; // 500mm grid
            const startGridX = Math.floor((minX - marginX)/gridSize)*gridSize;
            const endGridX = Math.ceil((maxX + marginX)/gridSize)*gridSize;
            const startGridY = Math.floor((minY - marginY)/gridSize)*gridSize;
            const endGridY = Math.ceil((maxY + marginY)/gridSize)*gridSize;

            ctx.font = '10px Arial';
            ctx.fillStyle = '#6b7280';
            ctx.textAlign = 'center';

            // Vertical Grid & X Labels
            for(let gx = startGridX; gx <= endGridX; gx += gridSize) {
                const p = toScreen(gx, 0);
                if(p.x >= plotXStart && p.x <= width) {
                    ctx.beginPath();
                    ctx.moveTo(p.x, plotYStart); 
                    ctx.lineTo(p.x, height - 20);
                    ctx.stroke();
                    // Label
                    if(gx % 1000 === 0) ctx.fillText(gx, p.x, height - 5);
                }
            }
            // Horizontal Grid & Y Labels
            ctx.textAlign = 'right';
            for(let gy = startGridY; gy <= endGridY; gy += gridSize) {
                const p = toScreen(0, gy);
                if(p.y >= plotYStart && p.y <= height - 20) {
                    ctx.beginPath();
                    ctx.moveTo(plotXStart, p.y); 
                    ctx.lineTo(width, p.y);
                    ctx.stroke();
                    // Label
                    if(gy % 1000 === 0) ctx.fillText(gy, plotXStart - 5, p.y + 3);
                }
            }
            ctx.restore();

            // Axis Titles
            ctx.save();
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("x (mm)", plotXStart + plotW/2, height - 5);
            
            ctx.translate(15, plotYStart + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("y (mm)", 0, 0);
            ctx.restore();


            // --- 1. Draw Original Static Vehicle (Upright - Solid Blue - Thinner) ---
            ctx.strokeStyle = '#2563eb'; // Standard Blue
            ctx.lineWidth = 1.0; 
            ctx.setLineDash([]);
            ctx.beginPath();
            
            // Left static
            const leftStatic = polyCoords.left.static_x.map((x, i) => ({x, y: polyCoords.left.static_y[i]}));
            if(leftStatic.length) {
                const start = toScreen(leftStatic[0].x, leftStatic[0].y);
                ctx.moveTo(start.x, start.y);
                for(let i=1; i<leftStatic.length; i++) {
                    const p = toScreen(leftStatic[i].x, leftStatic[i].y);
                    ctx.lineTo(p.x, p.y);
                }
            }
            // Right static
            const rightStatic = polyCoords.right.static_x.map((x, i) => ({x, y: polyCoords.right.static_y[i]}));
            if(rightStatic.length) {
                 const start = toScreen(rightStatic[0].x, rightStatic[0].y);
                 ctx.moveTo(start.x, start.y);
                 for(let i=1; i<rightStatic.length; i++) {
                     const p = toScreen(rightStatic[i].x, rightStatic[i].y);
                     ctx.lineTo(p.x, p.y);
                 }
            }
            ctx.stroke();

            // --- 2. Draw Rotated Static Vehicle (Dotted Blue + Shaded) ---
            
            // Build Polygon for Rotated Static
            const rotPoly = [];
            polyCoords.left.rot_static_x.forEach((x, i) => rotPoly.push({x: x, y: polyCoords.left.rot_static_y[i]}));
            // Reverse Right side
            for(let i = polyCoords.right.rot_static_x.length - 1; i >= 0; i--) {
                rotPoly.push({x: polyCoords.right.rot_static_x[i], y: polyCoords.right.rot_static_y[i]});
            }

            ctx.save();
            ctx.beginPath();
            if(rotPoly.length) {
                const s = toScreen(rotPoly[0].x, rotPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<rotPoly.length; i++) {
                    const p = toScreen(rotPoly[i].x, rotPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }
            // Fill
            ctx.fillStyle = 'rgba(59, 130, 246, 0.15)'; // Very light blue
            ctx.fill();
            // Stroke
            ctx.strokeStyle = '#2563eb'; // Blue
            ctx.lineWidth = 1.5;
            ctx.setLineDash([2, 3]); // Dotted
            ctx.stroke();
            ctx.restore();


            // --- 3. Construct Dynamic Envelope Polygon ---
            const fullPoly = [];
            // Left side normal order
            polyCoords.left.x.forEach((x, i) => fullPoly.push({x: x, y: polyCoords.left.y[i]}));
            // Right side REVERSE order
            for(let i = polyCoords.right.x.length - 1; i >= 0; i--) {
                fullPoly.push({x: polyCoords.right.x[i], y: polyCoords.right.y[i]});
            }

            // Determine Pass/Fail/Boundary for Title & Fill
            let globalStatus = 'PASS'; 
            const TOLERANCE_MM = 1e-9; // 0.000000001
            
            if (fullPoly.length > 0 && studyPoints.length > 0) {
                let hasFail = false;
                let hasBoundary = false;

                studyPoints.forEach((sp, idx) => {
                    const isStrictlyInside = pointInPolygon(sp, fullPoly);
                    const res = results[idx];
                    
                    let isLocalBoundary = false;
                    
                    // Check distance to envelope line
                    if (res && res.envX !== null) {
                         const dist = Math.abs(sp.x - res.envX);
                         if (dist <= TOLERANCE_MM) {
                             hasBoundary = true;
                             isLocalBoundary = true;
                         }
                    }
                    
                    // If not on boundary, check if strictly outside
                    if (!isLocalBoundary && !isStrictlyInside) {
                        hasFail = true;
                    }
                });

                if (hasFail) globalStatus = 'FAIL';
                else if (hasBoundary) globalStatus = 'BOUNDARY';
            }

            // --- 4. Draw Dynamic Envelope ---
            ctx.beginPath();
            if(fullPoly.length) {
                const s = toScreen(fullPoly[0].x, fullPoly[0].y);
                ctx.moveTo(s.x, s.y);
                for(let i=1; i<fullPoly.length; i++) {
                    const p = toScreen(fullPoly[i].x, fullPoly[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
            }

            // Fill: Color based on Pass/Fail/Boundary status
            if (globalStatus === 'FAIL') {
                ctx.fillStyle = 'rgba(254, 202, 202, 0.4)'; // Light Red
            } else if (globalStatus === 'BOUNDARY') {
                ctx.fillStyle = 'rgba(251, 191, 36, 0.4)'; // Amber/Orange
            } else {
                ctx.fillStyle = 'rgba(230, 249, 230, 0.4)'; // Light Green
            }
            ctx.fill();
            
            // Stroke: Red Dashed
            ctx.strokeStyle = '#FF6347'; // Tomato Red
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // --- Draw Pivot ---
            const piv = toScreen(PIVOT_POINT.x, PIVOT_POINT.y);
            ctx.fillStyle = 'black';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            
            // Draw Plus Sign
            const plusSize = 6;
            ctx.beginPath();
            ctx.moveTo(piv.x - plusSize, piv.y); ctx.lineTo(piv.x + plusSize, piv.y);
            ctx.moveTo(piv.x, piv.y - plusSize); ctx.lineTo(piv.x, piv.y + plusSize);
            ctx.stroke();

            // --- Draw Study Points & Annotations ---
            studyPoints.forEach((sp, idx) => {
                const scr = toScreen(sp.x, sp.y);
                
                // Draw Plus Marker (Green for Throw)
                ctx.strokeStyle = '#008000'; // Green
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(scr.x - 4, scr.y); ctx.lineTo(scr.x + 4, scr.y);
                ctx.moveTo(scr.x, scr.y - 4); ctx.lineTo(scr.x, scr.y + 4);
                ctx.stroke();

                // Only draw text annotations for the RIGHT side
                if (sp.side === 'right') {
                    // Draw Coordinate Annotations
                    ctx.font = '11px Arial';
                    ctx.fillStyle = '#008000';
                    
                    // y: label near center
                    const yLabelPos = toScreen(0, sp.y);
                    ctx.textAlign = 'right';
                    ctx.fillText(`y:${sp.y.toFixed(0)}`, yLabelPos.x - 10, yLabelPos.y + 4);

                    // x: label on axis (Drop line approach)
                    const axisY = height - 20; 

                    // Draw dashed drop line
                    ctx.save();
                    ctx.setLineDash([2, 2]);
                    ctx.strokeStyle = '#008000'; 
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(scr.x, scr.y);
                    ctx.lineTo(scr.x, axisY);
                    ctx.stroke();
                    ctx.restore();

                    // Draw Text at Axis
                    ctx.textAlign = 'center';
                    // ctx.fillText(`x:${sp.x.toFixed(0)}`, scr.x, height - 5);
                    ctx.fillText(`${sp.x.toFixed(0)}`, scr.x, height - 5);
                }


                // --- Draw Delta Lines & Text ---
                const res = results[idx];
                
                // 1. Static Delta Line (Red Dotted) - NOW TO ROTATED STATIC
                if(res.rotStaticX !== null) {
                    const statScr = toScreen(res.rotStaticX, sp.y);
                    ctx.beginPath();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([2, 2]);
                    ctx.moveTo(statScr.x, statScr.y);
                    ctx.lineTo(scr.x, scr.y);
                    ctx.stroke();
                    
                    // Small dot at intersection
                    ctx.fillStyle = 'black'; 
                    ctx.beginPath(); ctx.arc(statScr.x, statScr.y, 2, 0, 2*Math.PI); ctx.fill();

                    // Text only on Right side
                    if (sp.side === 'right') {
                        const dist = Math.abs(sp.x - res.rotStaticX);
                        ctx.font = 'bold 11px Arial';
                        ctx.fillStyle = 'red';
                        ctx.textAlign = 'left';
                        ctx.fillText(`Δ Static: ${dist.toFixed(1)}mm`, scr.x + 10, scr.y - 18);
                    }
                }

                // 2. Env Delta Line (Purple Dashed)
                if(res.envX !== null) {
                    const envScr = toScreen(res.envX, sp.y);
                    ctx.beginPath();
                    ctx.strokeStyle = '#800080'; // Purple
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.moveTo(envScr.x, envScr.y);
                    ctx.lineTo(scr.x, scr.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Text only on Right side
                    if (sp.side === 'right') {
                        const dist = Math.abs(sp.x - res.envX);
                        ctx.font = 'bold 11px Arial';
                        ctx.fillStyle = '#4B0082'; // Indigo/Purple
                        ctx.textAlign = 'left';
                        ctx.fillText(`Δ Env: ${dist.toFixed(1)}mm`, scr.x + 10, scr.y - 4);
                    }
                }

                // 3. NEW: Delta from Rotated Static to Original Static
                if(res.rotStaticX !== null && res.origStaticX !== null && sp.side === 'right') {
                    const rotScr = toScreen(res.rotStaticX, sp.y);
                    const origScr = toScreen(res.origStaticX, sp.y);

                    // Draw a small arrow or line connecting them
                    ctx.beginPath();
                    ctx.strokeStyle = '#2563eb'; // Blue
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);
                    // Draw slightly below the main point to avoid clutter
                    const yOffset = 15; 
                    const yDraw = rotScr.y + yOffset;
                    
                    ctx.moveTo(rotScr.x, yDraw);
                    ctx.lineTo(origScr.x, yDraw);
                    // Tick marks
                    ctx.moveTo(rotScr.x, yDraw - 3); ctx.lineTo(rotScr.x, yDraw + 3);
                    ctx.moveTo(origScr.x, yDraw - 3); ctx.lineTo(origScr.x, yDraw + 3);
                    ctx.stroke();

                    // Text
                    const dist = Math.abs(res.rotStaticX - res.origStaticX);
                    ctx.fillStyle = '#2563eb';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    const midX = (rotScr.x + origScr.x) / 2;
                    ctx.fillText(`Δ Rot: ${dist.toFixed(1)}`, midX, yDraw + 12);
                }
            });

            // --- TITLE BLOCK ---
            ctx.save();
            ctx.textAlign = 'center';
            ctx.fillStyle = 'black';
            
            // Main Title
            ctx.font = '16px Arial';
            const typeText = params.studyType === 1 ? "End Throw" : "Centre Throw";
            ctx.fillText(`Vehicle Outline with ${typeText}`, cx, 20);
            
            // Subtitle / Status
            ctx.font = '14px Arial';
            
            let statusText = "PASS (Inside)";
            if (globalStatus === 'FAIL') statusText = "FAIL (Outside)";
            else if (globalStatus === 'BOUNDARY') statusText = "BOUNDARY (On Line)";
            
            ctx.fillText(`Status: ${statusText} | Roll: ${params.roll.toFixed(1)}° | Lat: ${params.lat.toFixed(1)}mm | Bounce: ${params.bounce.toFixed(1)}mm`, cx, 40);
            ctx.restore();

            // --- LEGEND ---
            drawLegend(ctx, width - 130, 10);
        }

        function drawLegend(ctx, x, y) {
            const w = 120;
            const h = 135; // increased height
            
            // Box
            ctx.save();
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);

            // Items
            const items = [
                { color: 'black', text: 'Pivot (0, 1100)', type: 'symbol', symbol: '+' },
                { color: 'rgba(230, 249, 230, 1)', text: 'Throw Loop', type: 'rect' },
                { color: 'rgba(59, 130, 246, 0.4)', text: 'Rotated Static', type: 'dottedRect' }, // New
                { color: '#2563eb', text: 'Original Static', type: 'line' },
                { color: '#008000', text: 'End Throw (ET)', type: 'symbol', symbol: '+' },
                { color: 'red', text: 'Δ Static (to Rot)', type: 'dashed' },
                { color: '#2563eb', text: 'Δ Rotation', type: 'line' }, // New
                { color: '#800080', text: 'Δ Env', type: 'dashed' },
            ];

            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            let cy = y + 10;
            const lx = x + 10;
            const tx = x + 25;

            items.forEach(item => {
                ctx.fillStyle = 'black';
                ctx.fillText(item.text, tx, cy);

                if(item.type === 'line') {
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'dashed') {
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 2]);
                    ctx.beginPath(); ctx.moveTo(lx-6, cy); ctx.lineTo(lx+6, cy); ctx.stroke();
                } else if(item.type === 'rect') {
                    ctx.fillStyle = item.color;
                    ctx.strokeStyle = '#FF6347'; // Border for throw loop
                    ctx.setLineDash([2,1]);
                    ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6);
                    ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'dottedRect') {
                    ctx.fillStyle = item.color;
                    ctx.strokeStyle = '#2563eb';
                    ctx.setLineDash([1,2]);
                    ctx.lineWidth = 1;
                    ctx.fillRect(lx-6, cy-3, 12, 6);
                    ctx.strokeRect(lx-6, cy-3, 12, 6);
                } else if(item.type === 'symbol') {
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(lx-3, cy); ctx.lineTo(lx+3, cy);
                    ctx.moveTo(lx, cy-3); ctx.lineTo(lx, cy+3);
                    ctx.stroke();
                }

                cy += 15;
            });
            ctx.restore();
        }

        // --- Init ---
        // Add event listeners to all inputs to trigger recalc
        document.querySelectorAll('input').forEach(inp => {
            if(inp.type === 'number') {
                inp.addEventListener('input', runCalculation);
            }
        });
        
        // Handle window resize to redraw canvas
        window.addEventListener('resize', () => {
             runCalculation();
        });
        
        // Initial Run
        window.onload = runCalculation;

    </script>
</body>
</html>
